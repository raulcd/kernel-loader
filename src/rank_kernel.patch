diff --git a/cpp/src/arrow/chunk_resolver.cc b/cpp/src/arrow/chunk_resolver.cc
index 7fc259f38c..442479604c 100644
--- a/cpp/src/arrow/chunk_resolver.cc
+++ b/cpp/src/arrow/chunk_resolver.cc
@@ -26,7 +26,7 @@
 #include "arrow/array.h"
 #include "arrow/record_batch.h"
 
-namespace arrow {
+namespace arrow::vendored::internal {
 
 using util::span;
 
diff --git a/cpp/src/arrow/chunk_resolver.h b/cpp/src/arrow/chunk_resolver.h
index 3d6458167f..ad77e34904 100644
--- a/cpp/src/arrow/chunk_resolver.h
+++ b/cpp/src/arrow/chunk_resolver.h
@@ -28,7 +28,7 @@
 #include "arrow/util/macros.h"
 #include "arrow/util/span.h"
 
-namespace arrow {
+namespace arrow::vendored::internal {
 
 class ChunkResolver;
 
diff --git a/cpp/src/arrow/compute/api_vector.cc b/cpp/src/arrow/compute/api_vector.cc
index 53ceed1b08..73b2fd6b5f 100644
--- a/cpp/src/arrow/compute/api_vector.cc
+++ b/cpp/src/arrow/compute/api_vector.cc
@@ -44,11 +44,11 @@ using internal::checked_pointer_cast;
 
 namespace internal {
 
-using compute::DictionaryEncodeOptions;
-using compute::FilterOptions;
+using compute::vendored::DictionaryEncodeOptions;
+using compute::vendored::FilterOptions;
 using compute::NullPlacement;
-using compute::RankOptions;
-using compute::RankQuantileOptions;
+using compute::vendored::RankOptions;
+using compute::vendored::RankQuantileOptions;
 
 template <>
 struct EnumTraits<FilterOptions::NullSelectionBehavior>
@@ -118,12 +118,16 @@ struct EnumTraits<RankOptions::Tiebreaker>
 
 namespace compute {
 
+namespace vendored {
+
 // ----------------------------------------------------------------------
 // Function options
 
 namespace internal {
 namespace {
 using ::arrow::internal::DataMember;
+using ::arrow::compute::internal::GetFunctionOptionsType;
+
 static auto kFilterOptionsType = GetFunctionOptionsType<FilterOptions>(
     DataMember("null_selection_behavior", &FilterOptions::null_selection_behavior));
 static auto kTakeOptionsType = GetFunctionOptionsType<TakeOptions>(
@@ -473,6 +477,6 @@ Result<Datum> Scatter(const Datum& values, const Datum& indices,
                       const ScatterOptions& options, ExecContext* ctx) {
   return CallFunction("scatter", {values, indices}, &options, ctx);
 }
-
+}  // namespace vendored
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/api_vector.h b/cpp/src/arrow/compute/api_vector.h
index 22bb164719..24325e3fed 100644
--- a/cpp/src/arrow/compute/api_vector.h
+++ b/cpp/src/arrow/compute/api_vector.h
@@ -30,6 +30,8 @@ namespace compute {
 
 class ExecContext;
 
+namespace vendored {
+
 /// \addtogroup compute-concrete-options
 /// @{
 
@@ -811,5 +813,6 @@ Result<Datum> Scatter(const Datum& values, const Datum& indices,
                       const ScatterOptions& options = ScatterOptions::Defaults(),
                       ExecContext* ctx = NULLPTR);
 
+}  // namespace vendored
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/chunked_internal.cc b/cpp/src/arrow/compute/kernels/chunked_internal.cc
index e72b8e1f5b..e696cce3a5 100644
--- a/cpp/src/arrow/compute/kernels/chunked_internal.cc
+++ b/cpp/src/arrow/compute/kernels/chunked_internal.cc
@@ -22,7 +22,7 @@
 #include "arrow/record_batch.h"
 #include "arrow/util/logging.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::vendored::internal {
 
 std::vector<const Array*> GetArrayPointers(const ArrayVector& arrays) {
   std::vector<const Array*> pointers(arrays.size());
diff --git a/cpp/src/arrow/compute/kernels/chunked_internal.h b/cpp/src/arrow/compute/kernels/chunked_internal.h
index 5bc8233016..2478519407 100644
--- a/cpp/src/arrow/compute/kernels/chunked_internal.h
+++ b/cpp/src/arrow/compute/kernels/chunked_internal.h
@@ -28,7 +28,7 @@
 #include "arrow/compute/kernels/codegen_internal.h"
 #include "arrow/util/span.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::vendored::internal {
 
 // The target chunk in a chunked array.
 struct ResolvedChunk {
@@ -77,7 +77,7 @@ struct CompressedChunkLocation {
       : data_((index_in_chunk << kChunkIndexBits) | chunk_index) {}
 
   template <typename IndexType>
-  explicit operator TypedChunkLocation<IndexType>() {
+  explicit operator arrow::vendored::internal::TypedChunkLocation<IndexType>() {
     return {static_cast<IndexType>(chunk_index()),
             static_cast<IndexType>(index_in_chunk())};
   }
@@ -90,7 +90,7 @@ static_assert(sizeof(uint64_t) == sizeof(CompressedChunkLocation));
 
 class ChunkedArrayResolver {
  private:
-  ChunkResolver resolver_;
+  ::arrow::vendored::internal::ChunkResolver resolver_;
   util::span<const Array* const> chunks_;
   std::vector<const Array*> owned_chunks_;
 
diff --git a/cpp/src/arrow/compute/kernels/codegen_internal.h b/cpp/src/arrow/compute/kernels/codegen_internal.h
index 2a492f581f..f0ad233651 100644
--- a/cpp/src/arrow/compute/kernels/codegen_internal.h
+++ b/cpp/src/arrow/compute/kernels/codegen_internal.h
@@ -61,7 +61,7 @@ using internal::VisitBitBlocks;
 using internal::VisitBitBlocksVoid;
 using internal::VisitTwoBitBlocksVoid;
 
-namespace compute {
+namespace compute::vendored {
 namespace internal {
 
 /// KernelState adapter for the common case of kernels whose only
@@ -141,29 +141,6 @@ struct GetViewType<Type, enable_if_t<is_base_binary_type<Type>::value ||
   static T LogicalValue(PhysicalType value) { return value; }
 };
 
-template <>
-struct GetViewType<Decimal32Type> {
-  using T = Decimal32;
-  using PhysicalType = std::string_view;
-
-  static T LogicalValue(PhysicalType value) {
-    return Decimal32(reinterpret_cast<const uint8_t*>(value.data()));
-  }
-
-  static T LogicalValue(T value) { return value; }
-};
-
-template <>
-struct GetViewType<Decimal64Type> {
-  using T = Decimal64;
-  using PhysicalType = std::string_view;
-
-  static T LogicalValue(PhysicalType value) {
-    return Decimal64(reinterpret_cast<const uint8_t*>(value.data()));
-  }
-
-  static T LogicalValue(T value) { return value; }
-};
 
 template <>
 struct GetViewType<Decimal128Type> {
@@ -202,16 +179,6 @@ struct GetOutputType<Type, enable_if_t<is_string_like_type<Type>::value>> {
   using T = std::string;
 };
 
-template <>
-struct GetOutputType<Decimal32Type> {
-  using T = Decimal32;
-};
-
-template <>
-struct GetOutputType<Decimal64Type> {
-  using T = Decimal64;
-};
-
 template <>
 struct GetOutputType<Decimal128Type> {
   using T = Decimal128;
@@ -259,8 +226,7 @@ using enable_if_not_floating_value = enable_if_t<!std::is_floating_point<T>::val
 
 template <typename T, typename R = T>
 using enable_if_decimal_value =
-    enable_if_t<std::is_same<Decimal32, T>::value || std::is_same<Decimal64, T>::value ||
-                    std::is_same<Decimal128, T>::value ||
+    enable_if_t<std::is_same<Decimal128, T>::value ||
                     std::is_same<Decimal256, T>::value,
                 R>;
 
@@ -390,21 +356,6 @@ struct UnboxScalar<Type, enable_if_has_string_view<Type>> {
   }
 };
 
-template <>
-struct UnboxScalar<Decimal32Type> {
-  using T = Decimal32;
-  static const T& Unbox(const Scalar& val) {
-    return checked_cast<const Decimal32Scalar&>(val).value;
-  }
-};
-
-template <>
-struct UnboxScalar<Decimal64Type> {
-  using T = Decimal64;
-  static const T& Unbox(const Scalar& val) {
-    return checked_cast<const Decimal64Scalar&>(val).value;
-  }
-};
 
 template <>
 struct UnboxScalar<Decimal128Type> {
@@ -1170,10 +1121,6 @@ ArrayKernelExec GeneratePhysicalNumeric(detail::GetTypeId get_id) {
 template <template <typename... Args> class Generator, typename... Args>
 ArrayKernelExec GenerateDecimalToDecimal(detail::GetTypeId get_id) {
   switch (get_id.id) {
-    case Type::DECIMAL32:
-      return Generator<Decimal32Type, Args...>::Exec;
-    case Type::DECIMAL64:
-      return Generator<Decimal64Type, Args...>::Exec;
     case Type::DECIMAL128:
       return Generator<Decimal128Type, Args...>::Exec;
     case Type::DECIMAL256:
@@ -1369,10 +1316,6 @@ ArrayKernelExec GenerateTemporal(detail::GetTypeId get_id) {
 template <template <typename...> class Generator, typename Type0, typename... Args>
 ArrayKernelExec GenerateDecimal(detail::GetTypeId get_id) {
   switch (get_id.id) {
-    case Type::DECIMAL32:
-      return Generator<Type0, Decimal32Type, Args...>::Exec;
-    case Type::DECIMAL64:
-      return Generator<Type0, Decimal64Type, Args...>::Exec;
     case Type::DECIMAL128:
       return Generator<Type0, Decimal128Type, Args...>::Exec;
     case Type::DECIMAL256:
diff --git a/cpp/src/arrow/compute/kernels/util_internal.h b/cpp/src/arrow/compute/kernels/util_internal.h
index 1fe139c117..cbc0333735 100644
--- a/cpp/src/arrow/compute/kernels/util_internal.h
+++ b/cpp/src/arrow/compute/kernels/util_internal.h
@@ -38,6 +38,8 @@ namespace compute {
 
 class ScalarFunction;
 
+namespace vendored {
+
 namespace internal {
 
 template <typename T>
@@ -156,5 +158,6 @@ ArrayKernelExec GenerateArithmeticFloatingPoint(detail::GetTypeId get_id) {
 void AddNullExec(ScalarFunction* func);
 
 }  // namespace internal
+}  // namespace vendored
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/vector_array_sort.cc b/cpp/src/arrow/compute/kernels/vector_array_sort.cc
index b9cfd38a02..4cb31c777b 100644
--- a/cpp/src/arrow/compute/kernels/vector_array_sort.cc
+++ b/cpp/src/arrow/compute/kernels/vector_array_sort.cc
@@ -40,6 +40,7 @@ namespace arrow {
 using internal::checked_cast;
 
 namespace compute {
+namespace vendored {
 namespace internal {
 
 namespace {
@@ -693,5 +694,6 @@ void RegisterVectorArraySort(FunctionRegistry* registry) {
 }
 
 }  // namespace internal
+}  // namespace vendored
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/vector_rank.cc b/cpp/src/arrow/compute/kernels/vector_rank.cc
index 2efc61c2e6..121a920512 100644
--- a/cpp/src/arrow/compute/kernels/vector_rank.cc
+++ b/cpp/src/arrow/compute/kernels/vector_rank.cc
@@ -22,7 +22,7 @@
 #include "arrow/compute/kernels/vector_sort_internal.h"
 #include "arrow/compute/registry.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::vendored::internal {
 
 using ::arrow::util::span;
 
@@ -361,7 +361,7 @@ class RankMetaFunction : public RankMetaFunctionBase<RankMetaFunction> {
   }
 
   RankMetaFunction()
-      : RankMetaFunctionBase("rank", Arity::Unary(), rank_doc, GetDefaultRankOptions()) {}
+      : RankMetaFunctionBase("vendored_rank", Arity::Unary(), rank_doc, GetDefaultRankOptions()) {}
 };
 
 class RankQuantileMetaFunction : public RankMetaFunctionBase<RankQuantileMetaFunction> {
@@ -374,7 +374,7 @@ class RankQuantileMetaFunction : public RankMetaFunctionBase<RankQuantileMetaFun
   static RankerType GetRanker(const RankQuantileOptions& options) { return RankerType(); }
 
   RankQuantileMetaFunction()
-      : RankMetaFunctionBase("rank_quantile", Arity::Unary(), rank_quantile_doc,
+      : RankMetaFunctionBase("vendored_rank_quantile", Arity::Unary(), rank_quantile_doc,
                              GetDefaultQuantileRankOptions()) {}
 };
 
@@ -385,4 +385,4 @@ void RegisterVectorRank(FunctionRegistry* registry) {
   DCHECK_OK(registry->AddFunction(std::make_shared<RankQuantileMetaFunction>()));
 }
 
-}  // namespace arrow::compute::internal
+}  // namespace arrow::compute::vendored::internal
diff --git a/cpp/src/arrow/compute/kernels/vector_sort.cc b/cpp/src/arrow/compute/kernels/vector_sort.cc
index f9ae69730f..86258fe814 100644
--- a/cpp/src/arrow/compute/kernels/vector_sort.cc
+++ b/cpp/src/arrow/compute/kernels/vector_sort.cc
@@ -27,6 +27,7 @@ using internal::checked_cast;
 using util::span;
 
 namespace compute {
+namespace vendored {
 namespace internal {
 
 namespace {
@@ -366,7 +367,7 @@ class ConcreteRecordBatchColumnSorter<NullType> : public RecordBatchColumnSorter
 
 Result<std::vector<ResolvedRecordBatchSortKey>> ResolveRecordBatchSortKeys(
     const RecordBatch& batch, const std::vector<SortKey>& sort_keys) {
-  return ::arrow::compute::internal::ResolveSortKeys<ResolvedRecordBatchSortKey>(
+  return ::arrow::compute::vendored::internal::ResolveSortKeys<ResolvedRecordBatchSortKey>(
       batch, sort_keys);
 }
 
@@ -468,7 +469,7 @@ class RadixRecordBatchSorter {
 
   static Result<std::vector<ResolvedSortKey>> ResolveSortKeys(
       const RecordBatch& batch, const std::vector<SortKey>& sort_keys) {
-    return ::arrow::compute::internal::ResolveSortKeys<ResolvedSortKey>(batch, sort_keys);
+    return ::arrow::compute::vendored::internal::ResolveSortKeys<ResolvedSortKey>(batch, sort_keys);
   }
 
   const std::vector<ResolvedSortKey> sort_keys_;
@@ -522,7 +523,7 @@ class MultipleKeyRecordBatchSorter : public TypeVisitor {
   static std::vector<ResolvedSortKey> ResolveSortKeys(
       const RecordBatch& batch, const std::vector<SortKey>& sort_keys, Status* status) {
     const auto maybe_resolved =
-        ::arrow::compute::internal::ResolveSortKeys<ResolvedSortKey>(batch, sort_keys);
+        ::arrow::compute::vendored::internal::ResolveSortKeys<ResolvedSortKey>(batch, sort_keys);
     if (!maybe_resolved.ok()) {
       *status = maybe_resolved.status();
       return {};
@@ -1193,5 +1194,6 @@ void RegisterVectorSort(FunctionRegistry* registry) {
 #undef VISIT_SORTABLE_PHYSICAL_TYPES
 
 }  // namespace internal
+}  // namespace vendored
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/vector_sort_internal.h b/cpp/src/arrow/compute/kernels/vector_sort_internal.h
index 6288aa26ea..0385f061fb 100644
--- a/cpp/src/arrow/compute/kernels/vector_sort_internal.h
+++ b/cpp/src/arrow/compute/kernels/vector_sort_internal.h
@@ -29,7 +29,7 @@
 #include "arrow/type.h"
 #include "arrow/type_traits.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::vendored::internal {
 
 // Visit all physical types for which sorting is implemented.
 #define VISIT_SORTABLE_PHYSICAL_TYPES(VISIT) \
@@ -71,7 +71,7 @@ struct StablePartitioner {
 
 template <typename TypeClass>
 constexpr bool has_null_like_values() {
-  return is_physical_floating(TypeClass::type_id);
+  return is_floating(TypeClass::type_id) && TypeClass::type_id != Type::HALF_FLOAT;
 }
 
 // Compare two values, taking NaNs into account
@@ -761,9 +761,9 @@ struct ResolvedTableSortKey {
         order(order),
         null_count(null_count) {}
 
-  using LocationType = ::arrow::ChunkLocation;
+  using LocationType = ::arrow::vendored::internal::ChunkLocation;
 
-  ResolvedChunk GetChunk(::arrow::ChunkLocation loc) const {
+  ResolvedChunk GetChunk(::arrow::vendored::internal::ChunkLocation loc) const {
     return {chunks[loc.chunk_index], loc.index_in_chunk};
   }
 
@@ -788,7 +788,7 @@ struct ResolvedTableSortKey {
                                   null_count);
     };
 
-    return ::arrow::compute::internal::ResolveSortKeys<ResolvedTableSortKey>(
+    return ::arrow::compute::vendored::internal::ResolveSortKeys<ResolvedTableSortKey>(
         *table.schema(), sort_keys, factory);
   }
 
@@ -813,4 +813,4 @@ inline Result<std::shared_ptr<ArrayData>> MakeMutableFloat64Array(
   return ArrayData::Make(float64(), length, {nullptr, std::move(data)}, /*null_count=*/0);
 }
 
-}  // namespace arrow::compute::internal
+}  // namespace arrow::compute::vendored::internal
