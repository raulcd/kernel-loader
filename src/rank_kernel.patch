diff --git a/cpp/src/arrow/chunk_resolver.cc b/cpp/src/arrow/chunk_resolver.cc
index 7fc259f38c..2d9d50b337 100644
--- a/cpp/src/arrow/chunk_resolver.cc
+++ b/cpp/src/arrow/chunk_resolver.cc
@@ -26,7 +26,7 @@
 #include "arrow/array.h"
 #include "arrow/record_batch.h"
 
-namespace arrow {
+namespace arrow::internal {
 
 using util::span;
 
diff --git a/cpp/src/arrow/chunk_resolver.h b/cpp/src/arrow/chunk_resolver.h
index 3d6458167f..75f4d19b1f 100644
--- a/cpp/src/arrow/chunk_resolver.h
+++ b/cpp/src/arrow/chunk_resolver.h
@@ -28,7 +28,7 @@
 #include "arrow/util/macros.h"
 #include "arrow/util/span.h"
 
-namespace arrow {
+namespace arrow::internal {
 
 class ChunkResolver;
 
diff --git a/cpp/src/arrow/compute/kernels/chunked_internal.h b/cpp/src/arrow/compute/kernels/chunked_internal.h
index 5bc8233016..783740bfbd 100644
--- a/cpp/src/arrow/compute/kernels/chunked_internal.h
+++ b/cpp/src/arrow/compute/kernels/chunked_internal.h
@@ -77,7 +77,7 @@ struct CompressedChunkLocation {
       : data_((index_in_chunk << kChunkIndexBits) | chunk_index) {}
 
   template <typename IndexType>
-  explicit operator TypedChunkLocation<IndexType>() {
+  explicit operator arrow::internal::TypedChunkLocation<IndexType>() {
     return {static_cast<IndexType>(chunk_index()),
             static_cast<IndexType>(index_in_chunk())};
   }
@@ -90,7 +90,7 @@ static_assert(sizeof(uint64_t) == sizeof(CompressedChunkLocation));
 
 class ChunkedArrayResolver {
  private:
-  ChunkResolver resolver_;
+  ::arrow::internal::ChunkResolver resolver_;
   util::span<const Array* const> chunks_;
   std::vector<const Array*> owned_chunks_;
 
diff --git a/cpp/src/arrow/compute/kernels/codegen_internal.h b/cpp/src/arrow/compute/kernels/codegen_internal.h
index 2a492f581f..0832399be4 100644
--- a/cpp/src/arrow/compute/kernels/codegen_internal.h
+++ b/cpp/src/arrow/compute/kernels/codegen_internal.h
@@ -141,29 +141,6 @@ struct GetViewType<Type, enable_if_t<is_base_binary_type<Type>::value ||
   static T LogicalValue(PhysicalType value) { return value; }
 };
 
-template <>
-struct GetViewType<Decimal32Type> {
-  using T = Decimal32;
-  using PhysicalType = std::string_view;
-
-  static T LogicalValue(PhysicalType value) {
-    return Decimal32(reinterpret_cast<const uint8_t*>(value.data()));
-  }
-
-  static T LogicalValue(T value) { return value; }
-};
-
-template <>
-struct GetViewType<Decimal64Type> {
-  using T = Decimal64;
-  using PhysicalType = std::string_view;
-
-  static T LogicalValue(PhysicalType value) {
-    return Decimal64(reinterpret_cast<const uint8_t*>(value.data()));
-  }
-
-  static T LogicalValue(T value) { return value; }
-};
 
 template <>
 struct GetViewType<Decimal128Type> {
@@ -202,16 +179,6 @@ struct GetOutputType<Type, enable_if_t<is_string_like_type<Type>::value>> {
   using T = std::string;
 };
 
-template <>
-struct GetOutputType<Decimal32Type> {
-  using T = Decimal32;
-};
-
-template <>
-struct GetOutputType<Decimal64Type> {
-  using T = Decimal64;
-};
-
 template <>
 struct GetOutputType<Decimal128Type> {
   using T = Decimal128;
@@ -259,8 +226,7 @@ using enable_if_not_floating_value = enable_if_t<!std::is_floating_point<T>::val
 
 template <typename T, typename R = T>
 using enable_if_decimal_value =
-    enable_if_t<std::is_same<Decimal32, T>::value || std::is_same<Decimal64, T>::value ||
-                    std::is_same<Decimal128, T>::value ||
+    enable_if_t<std::is_same<Decimal128, T>::value ||
                     std::is_same<Decimal256, T>::value,
                 R>;
 
@@ -390,21 +356,6 @@ struct UnboxScalar<Type, enable_if_has_string_view<Type>> {
   }
 };
 
-template <>
-struct UnboxScalar<Decimal32Type> {
-  using T = Decimal32;
-  static const T& Unbox(const Scalar& val) {
-    return checked_cast<const Decimal32Scalar&>(val).value;
-  }
-};
-
-template <>
-struct UnboxScalar<Decimal64Type> {
-  using T = Decimal64;
-  static const T& Unbox(const Scalar& val) {
-    return checked_cast<const Decimal64Scalar&>(val).value;
-  }
-};
 
 template <>
 struct UnboxScalar<Decimal128Type> {
@@ -1170,10 +1121,6 @@ ArrayKernelExec GeneratePhysicalNumeric(detail::GetTypeId get_id) {
 template <template <typename... Args> class Generator, typename... Args>
 ArrayKernelExec GenerateDecimalToDecimal(detail::GetTypeId get_id) {
   switch (get_id.id) {
-    case Type::DECIMAL32:
-      return Generator<Decimal32Type, Args...>::Exec;
-    case Type::DECIMAL64:
-      return Generator<Decimal64Type, Args...>::Exec;
     case Type::DECIMAL128:
       return Generator<Decimal128Type, Args...>::Exec;
     case Type::DECIMAL256:
@@ -1369,10 +1316,6 @@ ArrayKernelExec GenerateTemporal(detail::GetTypeId get_id) {
 template <template <typename...> class Generator, typename Type0, typename... Args>
 ArrayKernelExec GenerateDecimal(detail::GetTypeId get_id) {
   switch (get_id.id) {
-    case Type::DECIMAL32:
-      return Generator<Type0, Decimal32Type, Args...>::Exec;
-    case Type::DECIMAL64:
-      return Generator<Type0, Decimal64Type, Args...>::Exec;
     case Type::DECIMAL128:
       return Generator<Type0, Decimal128Type, Args...>::Exec;
     case Type::DECIMAL256:
diff --git a/cpp/src/arrow/compute/kernels/vector_rank.cc b/cpp/src/arrow/compute/kernels/vector_rank.cc
index 2efc61c2e6..064261bc17 100644
--- a/cpp/src/arrow/compute/kernels/vector_rank.cc
+++ b/cpp/src/arrow/compute/kernels/vector_rank.cc
@@ -361,7 +362,7 @@ class RankMetaFunction : public RankMetaFunctionBase<RankMetaFunction> {
   }
 
   RankMetaFunction()
-      : RankMetaFunctionBase("rank", Arity::Unary(), rank_doc, GetDefaultRankOptions()) {}
+      : RankMetaFunctionBase("vendored_rank", Arity::Unary(), rank_doc, GetDefaultRankOptions()) {}
 };
 
 class RankQuantileMetaFunction : public RankMetaFunctionBase<RankQuantileMetaFunction> {
@@ -374,7 +375,7 @@ class RankQuantileMetaFunction : public RankMetaFunctionBase<RankQuantileMetaFun
   static RankerType GetRanker(const RankQuantileOptions& options) { return RankerType(); }
 
   RankQuantileMetaFunction()
-      : RankMetaFunctionBase("rank_quantile", Arity::Unary(), rank_quantile_doc,
+      : RankMetaFunctionBase("vendored_rank_quantile", Arity::Unary(), rank_quantile_doc,
                              GetDefaultQuantileRankOptions()) {}
 };
 
@@ -380,9 +380,11 @@ class RankQuantileMetaFunction : public RankMetaFunctionBase<RankQuantileMetaFun
 
 }  // namespace
 
+namespace vendored {
 void RegisterVectorRank(FunctionRegistry* registry) {
   DCHECK_OK(registry->AddFunction(std::make_shared<RankMetaFunction>()));
   DCHECK_OK(registry->AddFunction(std::make_shared<RankQuantileMetaFunction>()));
 }
+}  // namespace vendored
 
 }  // namespace arrow::compute::internal

diff --git a/cpp/src/arrow/compute/kernels/vector_sort_internal.h b/cpp/src/arrow/compute/kernels/vector_sort_internal.h
index 6288aa26ea..57304562c3 100644
--- a/cpp/src/arrow/compute/kernels/vector_sort_internal.h
+++ b/cpp/src/arrow/compute/kernels/vector_sort_internal.h
@@ -761,9 +761,9 @@ struct ResolvedTableSortKey {
         order(order),
         null_count(null_count) {}
 
-  using LocationType = ::arrow::ChunkLocation;
+  using LocationType = ::arrow::internal::ChunkLocation;
 
-  ResolvedChunk GetChunk(::arrow::ChunkLocation loc) const {
+  ResolvedChunk GetChunk(::arrow::internal::ChunkLocation loc) const {
     return {chunks[loc.chunk_index], loc.index_in_chunk};
   }
 
