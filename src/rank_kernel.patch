diff --git a/cpp/src/arrow/chunk_resolver.cc b/cpp/src/arrow/chunk_resolver.cc
index 7fc259f38c..2d9d50b337 100644
--- a/cpp/src/arrow/chunk_resolver.cc
+++ b/cpp/src/arrow/chunk_resolver.cc
@@ -26,7 +26,7 @@
 #include "arrow/array.h"
 #include "arrow/record_batch.h"
 
-namespace arrow {
+namespace arrow::internal {
 
 using util::span;
 
diff --git a/cpp/src/arrow/chunk_resolver.h b/cpp/src/arrow/chunk_resolver.h
index 3d6458167f..75f4d19b1f 100644
--- a/cpp/src/arrow/chunk_resolver.h
+++ b/cpp/src/arrow/chunk_resolver.h
@@ -28,7 +28,7 @@
 #include "arrow/util/macros.h"
 #include "arrow/util/span.h"
 
-namespace arrow {
+namespace arrow::internal {
 
 class ChunkResolver;
 
diff --git a/cpp/src/arrow/compute/api_aggregate.cc b/cpp/src/arrow/compute/api_aggregate.cc
index 20d3ce2faf..8976be5aa1 100644
--- a/cpp/src/arrow/compute/api_aggregate.cc
+++ b/cpp/src/arrow/compute/api_aggregate.cc
@@ -25,6 +25,7 @@
 
 namespace arrow {
 namespace internal {
+namespace vendored {
 
 template <>
 struct EnumTraits<compute::CountOptions::CountMode>
@@ -84,7 +85,7 @@ struct EnumTraits<compute::PivotWiderOptions::UnexpectedKeyBehavior>
     return "<INVALID>";
   }
 };
-
+}  // namespace vendored
 }  // namespace internal
 
 namespace compute {
@@ -96,7 +97,7 @@ using ::arrow::internal::checked_cast;
 
 namespace internal {
 namespace {
-using ::arrow::internal::DataMember;
+using ::arrow::internal::vendored::DataMember;
 static auto kScalarAggregateOptionsType = GetFunctionOptionsType<ScalarAggregateOptions>(
     DataMember("skip_nulls", &ScalarAggregateOptions::skip_nulls),
     DataMember("min_count", &ScalarAggregateOptions::min_count));
diff --git a/cpp/src/arrow/compute/api_vector.cc b/cpp/src/arrow/compute/api_vector.cc
index 53ceed1b08..da356ef3fc 100644
--- a/cpp/src/arrow/compute/api_vector.cc
+++ b/cpp/src/arrow/compute/api_vector.cc
@@ -42,13 +42,13 @@ namespace arrow {
 using internal::checked_cast;
 using internal::checked_pointer_cast;
 
-namespace internal {
+namespace internal::vendored {
 
-using compute::DictionaryEncodeOptions;
-using compute::FilterOptions;
+using compute::internal::vendored::DictionaryEncodeOptions;
+using compute::internal::vendored::FilterOptions;
 using compute::NullPlacement;
-using compute::RankOptions;
-using compute::RankQuantileOptions;
+using compute::internal::vendored::RankOptions;
+using compute::internal::vendored::RankQuantileOptions;
 
 template <>
 struct EnumTraits<FilterOptions::NullSelectionBehavior>
@@ -122,8 +122,9 @@ namespace compute {
 // Function options
 
 namespace internal {
+namespace vendored {
 namespace {
-using ::arrow::internal::DataMember;
+using ::arrow::internal::vendored::DataMember;
 static auto kFilterOptionsType = GetFunctionOptionsType<FilterOptions>(
     DataMember("null_selection_behavior", &FilterOptions::null_selection_behavior));
 static auto kTakeOptionsType = GetFunctionOptionsType<TakeOptions>(
@@ -166,67 +167,66 @@ static auto kInversePermutationOptionsType =
 static auto kScatterOptionsType = GetFunctionOptionsType<ScatterOptions>(
     DataMember("max_index", &ScatterOptions::max_index));
 }  // namespace
-}  // namespace internal
 
 FilterOptions::FilterOptions(NullSelectionBehavior null_selection)
-    : FunctionOptions(internal::kFilterOptionsType),
+    : FunctionOptions(kFilterOptionsType),
       null_selection_behavior(null_selection) {}
 constexpr char FilterOptions::kTypeName[];
 
 TakeOptions::TakeOptions(bool boundscheck)
-    : FunctionOptions(internal::kTakeOptionsType), boundscheck(boundscheck) {}
+    : FunctionOptions(kTakeOptionsType), boundscheck(boundscheck) {}
 constexpr char TakeOptions::kTypeName[];
 
 DictionaryEncodeOptions::DictionaryEncodeOptions(NullEncodingBehavior null_encoding)
-    : FunctionOptions(internal::kDictionaryEncodeOptionsType),
+    : FunctionOptions(kDictionaryEncodeOptionsType),
       null_encoding_behavior(null_encoding) {}
 constexpr char DictionaryEncodeOptions::kTypeName[];
 
 RunEndEncodeOptions::RunEndEncodeOptions(std::shared_ptr<DataType> run_end_type)
-    : FunctionOptions(internal::kRunEndEncodeOptionsType),
+    : FunctionOptions(kRunEndEncodeOptionsType),
       run_end_type{std::move(run_end_type)} {}
 
 ArraySortOptions::ArraySortOptions(SortOrder order, NullPlacement null_placement)
-    : FunctionOptions(internal::kArraySortOptionsType),
+    : FunctionOptions(kArraySortOptionsType),
       order(order),
       null_placement(null_placement) {}
 constexpr char ArraySortOptions::kTypeName[];
 
 SortOptions::SortOptions(std::vector<SortKey> sort_keys, NullPlacement null_placement)
-    : FunctionOptions(internal::kSortOptionsType),
+    : FunctionOptions(kSortOptionsType),
       sort_keys(std::move(sort_keys)),
       null_placement(null_placement) {}
 SortOptions::SortOptions(const Ordering& ordering)
-    : FunctionOptions(internal::kSortOptionsType),
+    : FunctionOptions(kSortOptionsType),
       sort_keys(ordering.sort_keys()),
       null_placement(ordering.null_placement()) {}
 constexpr char SortOptions::kTypeName[];
 
 PartitionNthOptions::PartitionNthOptions(int64_t pivot, NullPlacement null_placement)
-    : FunctionOptions(internal::kPartitionNthOptionsType),
+    : FunctionOptions(kPartitionNthOptionsType),
       pivot(pivot),
       null_placement(null_placement) {}
 constexpr char PartitionNthOptions::kTypeName[];
 
 SelectKOptions::SelectKOptions(int64_t k, std::vector<SortKey> sort_keys)
-    : FunctionOptions(internal::kSelectKOptionsType),
+    : FunctionOptions(kSelectKOptionsType),
       k(k),
       sort_keys(std::move(sort_keys)) {}
 constexpr char SelectKOptions::kTypeName[];
 
 CumulativeOptions::CumulativeOptions(bool skip_nulls)
-    : FunctionOptions(internal::kCumulativeOptionsType), skip_nulls(skip_nulls) {}
+    : FunctionOptions(kCumulativeOptionsType), skip_nulls(skip_nulls) {}
 CumulativeOptions::CumulativeOptions(double start, bool skip_nulls)
     : CumulativeOptions(std::make_shared<DoubleScalar>(start), skip_nulls) {}
 CumulativeOptions::CumulativeOptions(std::shared_ptr<Scalar> start, bool skip_nulls)
-    : FunctionOptions(internal::kCumulativeOptionsType),
+    : FunctionOptions(kCumulativeOptionsType),
       start(std::move(start)),
       skip_nulls(skip_nulls) {}
 constexpr char CumulativeOptions::kTypeName[];
 
 RankOptions::RankOptions(std::vector<SortKey> sort_keys, NullPlacement null_placement,
                          RankOptions::Tiebreaker tiebreaker)
-    : FunctionOptions(internal::kRankOptionsType),
+    : FunctionOptions(kRankOptionsType),
       sort_keys(std::move(sort_keys)),
       null_placement(null_placement),
       tiebreaker(tiebreaker) {}
@@ -234,28 +234,28 @@ constexpr char RankOptions::kTypeName[];
 
 RankQuantileOptions::RankQuantileOptions(std::vector<SortKey> sort_keys,
                                          NullPlacement null_placement)
-    : FunctionOptions(internal::kRankQuantileOptionsType),
+    : FunctionOptions(kRankQuantileOptionsType),
       sort_keys(std::move(sort_keys)),
       null_placement(null_placement) {}
 constexpr char RankQuantileOptions::kTypeName[];
 
 PairwiseOptions::PairwiseOptions(int64_t periods)
-    : FunctionOptions(internal::kPairwiseOptionsType), periods(periods) {}
+    : FunctionOptions(kPairwiseOptionsType), periods(periods) {}
 constexpr char PairwiseOptions::kTypeName[];
 
 ListFlattenOptions::ListFlattenOptions(bool recursive)
-    : FunctionOptions(internal::kListFlattenOptionsType), recursive(recursive) {}
+    : FunctionOptions(kListFlattenOptionsType), recursive(recursive) {}
 constexpr char ListFlattenOptions::kTypeName[];
 
 InversePermutationOptions::InversePermutationOptions(
     int64_t max_index, std::shared_ptr<DataType> output_type)
-    : FunctionOptions(internal::kInversePermutationOptionsType),
+    : FunctionOptions(kInversePermutationOptionsType),
       max_index(max_index),
       output_type(std::move(output_type)) {}
 constexpr char InversePermutationOptions::kTypeName[];
 
 ScatterOptions::ScatterOptions(int64_t max_index)
-    : FunctionOptions(internal::kScatterOptionsType), max_index(max_index) {}
+    : FunctionOptions(kScatterOptionsType), max_index(max_index) {}
 constexpr char ScatterOptions::kTypeName[];
 
 namespace internal {
@@ -473,6 +473,7 @@ Result<Datum> Scatter(const Datum& values, const Datum& indices,
                       const ScatterOptions& options, ExecContext* ctx) {
   return CallFunction("scatter", {values, indices}, &options, ctx);
 }
-
+}  // namespace vendored
+}  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/api_vector.h b/cpp/src/arrow/compute/api_vector.h
index 22bb164719..1bcc2362cc 100644
--- a/cpp/src/arrow/compute/api_vector.h
+++ b/cpp/src/arrow/compute/api_vector.h
@@ -30,6 +30,8 @@ namespace compute {
 
 class ExecContext;
 
+namespace internal::vendored {
+
 /// \addtogroup compute-concrete-options
 /// @{
 
@@ -811,5 +813,6 @@ Result<Datum> Scatter(const Datum& values, const Datum& indices,
                       const ScatterOptions& options = ScatterOptions::Defaults(),
                       ExecContext* ctx = NULLPTR);
 
+}  // namespace internal::vendored
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/function_internal.h b/cpp/src/arrow/compute/function_internal.h
index 9d8928466b..5f9a607ee9 100644
--- a/cpp/src/arrow/compute/function_internal.h
+++ b/cpp/src/arrow/compute/function_internal.h
@@ -42,6 +42,7 @@ struct StructScalar;
 using ::arrow::internal::checked_cast;
 
 namespace internal {
+namespace vendored {
 template <>
 struct EnumTraits<compute::SortOrder>
     : BasicEnumTraits<compute::SortOrder, compute::SortOrder::Ascending,
@@ -57,13 +58,14 @@ struct EnumTraits<compute::SortOrder>
     return "<INVALID>";
   }
 };
+}  // namespace vendored
 }  // namespace internal
 
 namespace compute {
 namespace internal {
 
-using arrow::internal::EnumTraits;
-using arrow::internal::has_enum_traits;
+using arrow::internal::vendored::EnumTraits;
+using arrow::internal::vendored::has_enum_traits;
 
 template <typename Enum, typename CType = typename std::underlying_type<Enum>::type>
 Result<Enum> ValidateEnumValue(CType raw) {
@@ -656,7 +658,7 @@ template <typename Options, typename... Properties>
 const FunctionOptionsType* GetFunctionOptionsType(const Properties&... properties) {
   static const class OptionsType : public GenericOptionsType {
    public:
-    explicit OptionsType(const arrow::internal::PropertyTuple<Properties...> properties)
+    explicit OptionsType(const arrow::internal::vendored::PropertyTuple<Properties...> properties)
         : properties_(properties) {}
 
     const char* type_name() const override { return Options::kTypeName; }
@@ -694,8 +696,8 @@ const FunctionOptionsType* GetFunctionOptionsType(const Properties&... propertie
     }
 
    private:
-    const arrow::internal::PropertyTuple<Properties...> properties_;
-  } instance(arrow::internal::MakeProperties(properties...));
+    const arrow::internal::vendored::PropertyTuple<Properties...> properties_;
+  } instance(arrow::internal::vendored::MakeProperties(properties...));
   return &instance;
 }
 
diff --git a/cpp/src/arrow/compute/kernels/aggregate_internal.h b/cpp/src/arrow/compute/kernels/aggregate_internal.h
index 23aa20eddc..0282657841 100644
--- a/cpp/src/arrow/compute/kernels/aggregate_internal.h
+++ b/cpp/src/arrow/compute/kernels/aggregate_internal.h
@@ -53,16 +53,6 @@ struct FindAccumulatorType<I, enable_if_floating_point<I>> {
   using Type = DoubleType;
 };
 
-template <typename I>
-struct FindAccumulatorType<I, enable_if_decimal32<I>> {
-  using Type = Decimal32Type;
-};
-
-template <typename I>
-struct FindAccumulatorType<I, enable_if_decimal64<I>> {
-  using Type = Decimal64Type;
-};
-
 template <typename I>
 struct FindAccumulatorType<I, enable_if_decimal128<I>> {
   using Type = Decimal128Type;
diff --git a/cpp/src/arrow/compute/kernels/aggregate_pivot.cc b/cpp/src/arrow/compute/kernels/aggregate_pivot.cc
index bcc2f53ac1..47c11ec8bf 100644
--- a/cpp/src/arrow/compute/kernels/aggregate_pivot.cc
+++ b/cpp/src/arrow/compute/kernels/aggregate_pivot.cc
@@ -23,7 +23,7 @@
 #include "arrow/util/bit_run_reader.h"
 #include "arrow/util/logging.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 namespace {
 
 using arrow::internal::VisitSetBitRunsVoid;
@@ -175,7 +175,7 @@ void RegisterScalarAggregatePivot(FunctionRegistry* registry) {
   static auto default_pivot_options = PivotWiderOptions::Defaults();
 
   auto func = std::make_shared<ScalarAggregateFunction>(
-      "pivot_wider", Arity::Binary(), pivot_doc, &default_pivot_options);
+      "vendored_pivot_wider", Arity::Binary(), pivot_doc, &default_pivot_options);
 
   for (auto key_type : BaseBinaryTypes()) {
     auto sig = KernelSignature::Make({key_type->id(), InputType::Any()},
diff --git a/cpp/src/arrow/compute/kernels/chunked_internal.cc b/cpp/src/arrow/compute/kernels/chunked_internal.cc
index e72b8e1f5b..dcc72c427c 100644
--- a/cpp/src/arrow/compute/kernels/chunked_internal.cc
+++ b/cpp/src/arrow/compute/kernels/chunked_internal.cc
@@ -22,7 +22,7 @@
 #include "arrow/record_batch.h"
 #include "arrow/util/logging.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 std::vector<const Array*> GetArrayPointers(const ArrayVector& arrays) {
   std::vector<const Array*> pointers(arrays.size());
diff --git a/cpp/src/arrow/compute/kernels/chunked_internal.h b/cpp/src/arrow/compute/kernels/chunked_internal.h
index 5bc8233016..2884acb541 100644
--- a/cpp/src/arrow/compute/kernels/chunked_internal.h
+++ b/cpp/src/arrow/compute/kernels/chunked_internal.h
@@ -28,7 +28,7 @@
 #include "arrow/compute/kernels/codegen_internal.h"
 #include "arrow/util/span.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 // The target chunk in a chunked array.
 struct ResolvedChunk {
@@ -77,7 +77,7 @@ struct CompressedChunkLocation {
       : data_((index_in_chunk << kChunkIndexBits) | chunk_index) {}
 
   template <typename IndexType>
-  explicit operator TypedChunkLocation<IndexType>() {
+  explicit operator arrow::internal::TypedChunkLocation<IndexType>() {
     return {static_cast<IndexType>(chunk_index()),
             static_cast<IndexType>(index_in_chunk())};
   }
@@ -90,7 +90,7 @@ static_assert(sizeof(uint64_t) == sizeof(CompressedChunkLocation));
 
 class ChunkedArrayResolver {
  private:
-  ChunkResolver resolver_;
+  ::arrow::internal::ChunkResolver resolver_;
   util::span<const Array* const> chunks_;
   std::vector<const Array*> owned_chunks_;
 
diff --git a/cpp/src/arrow/compute/kernels/codegen_internal.h b/cpp/src/arrow/compute/kernels/codegen_internal.h
index 2a492f581f..0832399be4 100644
--- a/cpp/src/arrow/compute/kernels/codegen_internal.h
+++ b/cpp/src/arrow/compute/kernels/codegen_internal.h
@@ -141,29 +141,6 @@ struct GetViewType<Type, enable_if_t<is_base_binary_type<Type>::value ||
   static T LogicalValue(PhysicalType value) { return value; }
 };
 
-template <>
-struct GetViewType<Decimal32Type> {
-  using T = Decimal32;
-  using PhysicalType = std::string_view;
-
-  static T LogicalValue(PhysicalType value) {
-    return Decimal32(reinterpret_cast<const uint8_t*>(value.data()));
-  }
-
-  static T LogicalValue(T value) { return value; }
-};
-
-template <>
-struct GetViewType<Decimal64Type> {
-  using T = Decimal64;
-  using PhysicalType = std::string_view;
-
-  static T LogicalValue(PhysicalType value) {
-    return Decimal64(reinterpret_cast<const uint8_t*>(value.data()));
-  }
-
-  static T LogicalValue(T value) { return value; }
-};
 
 template <>
 struct GetViewType<Decimal128Type> {
@@ -202,16 +179,6 @@ struct GetOutputType<Type, enable_if_t<is_string_like_type<Type>::value>> {
   using T = std::string;
 };
 
-template <>
-struct GetOutputType<Decimal32Type> {
-  using T = Decimal32;
-};
-
-template <>
-struct GetOutputType<Decimal64Type> {
-  using T = Decimal64;
-};
-
 template <>
 struct GetOutputType<Decimal128Type> {
   using T = Decimal128;
@@ -259,8 +226,7 @@ using enable_if_not_floating_value = enable_if_t<!std::is_floating_point<T>::val
 
 template <typename T, typename R = T>
 using enable_if_decimal_value =
-    enable_if_t<std::is_same<Decimal32, T>::value || std::is_same<Decimal64, T>::value ||
-                    std::is_same<Decimal128, T>::value ||
+    enable_if_t<std::is_same<Decimal128, T>::value ||
                     std::is_same<Decimal256, T>::value,
                 R>;
 
@@ -390,21 +356,6 @@ struct UnboxScalar<Type, enable_if_has_string_view<Type>> {
   }
 };
 
-template <>
-struct UnboxScalar<Decimal32Type> {
-  using T = Decimal32;
-  static const T& Unbox(const Scalar& val) {
-    return checked_cast<const Decimal32Scalar&>(val).value;
-  }
-};
-
-template <>
-struct UnboxScalar<Decimal64Type> {
-  using T = Decimal64;
-  static const T& Unbox(const Scalar& val) {
-    return checked_cast<const Decimal64Scalar&>(val).value;
-  }
-};
 
 template <>
 struct UnboxScalar<Decimal128Type> {
@@ -1170,10 +1121,6 @@ ArrayKernelExec GeneratePhysicalNumeric(detail::GetTypeId get_id) {
 template <template <typename... Args> class Generator, typename... Args>
 ArrayKernelExec GenerateDecimalToDecimal(detail::GetTypeId get_id) {
   switch (get_id.id) {
-    case Type::DECIMAL32:
-      return Generator<Decimal32Type, Args...>::Exec;
-    case Type::DECIMAL64:
-      return Generator<Decimal64Type, Args...>::Exec;
     case Type::DECIMAL128:
       return Generator<Decimal128Type, Args...>::Exec;
     case Type::DECIMAL256:
@@ -1369,10 +1316,6 @@ ArrayKernelExec GenerateTemporal(detail::GetTypeId get_id) {
 template <template <typename...> class Generator, typename Type0, typename... Args>
 ArrayKernelExec GenerateDecimal(detail::GetTypeId get_id) {
   switch (get_id.id) {
-    case Type::DECIMAL32:
-      return Generator<Type0, Decimal32Type, Args...>::Exec;
-    case Type::DECIMAL64:
-      return Generator<Type0, Decimal64Type, Args...>::Exec;
     case Type::DECIMAL128:
       return Generator<Type0, Decimal128Type, Args...>::Exec;
     case Type::DECIMAL256:
diff --git a/cpp/src/arrow/compute/kernels/hash_aggregate.cc b/cpp/src/arrow/compute/kernels/hash_aggregate.cc
index e84c3c2dc1..069e369501 100644
--- a/cpp/src/arrow/compute/kernels/hash_aggregate.cc
+++ b/cpp/src/arrow/compute/kernels/hash_aggregate.cc
@@ -64,6 +64,7 @@ using util::span;
 
 namespace compute {
 namespace internal {
+namespace vendored {
 namespace {
 
 /// C++ abstract base class for the HashAggregateKernel interface.
@@ -849,7 +850,7 @@ using arrow::internal::int128_t;
 template <typename Type>
 struct GroupedStatisticImpl : public GroupedAggregator {
   using CType = typename TypeTraits<Type>::CType;
-  using SumType = typename internal::GetSumType<Type>::SumType;
+  using SumType = typename arrow::compute::internal::GetSumType<Type>::SumType;
 
   // This method is defined solely to make GroupedStatisticImpl instantiable
   // in ConsumeImpl below. It will be redefined in subclasses.
@@ -923,8 +924,6 @@ struct GroupedStatisticImpl : public GroupedAggregator {
   double ToDouble(T value) const {
     return static_cast<double>(value);
   }
-  double ToDouble(const Decimal32& value) const { return value.ToDouble(decimal_scale_); }
-  double ToDouble(const Decimal64& value) const { return value.ToDouble(decimal_scale_); }
   double ToDouble(const Decimal128& value) const {
     return value.ToDouble(decimal_scale_);
   }
@@ -1276,7 +1275,7 @@ Status AddHashAggregateStatisticKernels(HashAggregateFunction* func,
   RETURN_NOT_OK(AddHashAggKernels(UnsignedIntTypes(), make_kernel, func));
   RETURN_NOT_OK(AddHashAggKernels(FloatingPointTypes(), make_kernel, func));
   RETURN_NOT_OK(AddHashAggKernels(
-      {decimal32(1, 1), decimal64(1, 1), decimal128(1, 1), decimal256(1, 1)}, make_kernel,
+      {decimal128(1, 1), decimal256(1, 1)}, make_kernel,
       func));
   return Status::OK();
 }
@@ -1319,8 +1318,6 @@ struct GroupedTDigestImpl : public GroupedAggregator {
   double ToDouble(T value) const {
     return static_cast<double>(value);
   }
-  double ToDouble(const Decimal32& value) const { return value.ToDouble(decimal_scale_); }
-  double ToDouble(const Decimal64& value) const { return value.ToDouble(decimal_scale_); }
   double ToDouble(const Decimal128& value) const {
     return value.ToDouble(decimal_scale_);
   }
@@ -1500,18 +1497,6 @@ struct AntiExtrema<double> {
   static constexpr double anti_max() { return -std::numeric_limits<double>::infinity(); }
 };
 
-template <>
-struct AntiExtrema<Decimal32> {
-  static constexpr Decimal32 anti_min() { return BasicDecimal32::GetMaxSentinel(); }
-  static constexpr Decimal32 anti_max() { return BasicDecimal32::GetMinSentinel(); }
-};
-
-template <>
-struct AntiExtrema<Decimal64> {
-  static constexpr Decimal64 anti_min() { return BasicDecimal64::GetMaxSentinel(); }
-  static constexpr Decimal64 anti_max() { return BasicDecimal64::GetMinSentinel(); }
-};
-
 template <>
 struct AntiExtrema<Decimal128> {
   static constexpr Decimal128 anti_min() { return BasicDecimal128::GetMaxSentinel(); }
@@ -4021,90 +4006,7 @@ void RegisterHashAggregateBasic(FunctionRegistry* registry) {
 
   {
     auto func = std::make_shared<HashAggregateFunction>(
-        "hash_count", Arity::Binary(), hash_count_doc, &default_count_options);
-
-    DCHECK_OK(func->AddKernel(
-        MakeKernel(InputType::Any(), HashAggregateInit<GroupedCountImpl>)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>("hash_count_all", Arity::Unary(),
-                                                        hash_count_all_doc, NULLPTR);
-
-    DCHECK_OK(func->AddKernel(MakeUnaryKernel(HashAggregateInit<GroupedCountAllImpl>)));
-    auto status = registry->AddFunction(std::move(func));
-    DCHECK_OK(status);
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_sum", Arity::Binary(), hash_sum_doc, &default_scalar_aggregate_options);
-    DCHECK_OK(AddHashAggKernels({boolean()}, GroupedSumFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels(SignedIntTypes(), GroupedSumFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels(UnsignedIntTypes(), GroupedSumFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(FloatingPointTypes(), GroupedSumFactory::Make, func.get()));
-    // Type parameters are ignored
-    DCHECK_OK(AddHashAggKernels({decimal128(1, 1), decimal256(1, 1)},
-                                GroupedSumFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels({null()}, GroupedSumFactory::Make, func.get()));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_product", Arity::Binary(), hash_product_doc,
-        &default_scalar_aggregate_options);
-    DCHECK_OK(AddHashAggKernels({boolean()}, GroupedProductFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(SignedIntTypes(), GroupedProductFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(UnsignedIntTypes(), GroupedProductFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(FloatingPointTypes(), GroupedProductFactory::Make, func.get()));
-    // Type parameters are ignored
-    DCHECK_OK(AddHashAggKernels({decimal128(1, 1), decimal256(1, 1)},
-                                GroupedProductFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels({null()}, GroupedProductFactory::Make, func.get()));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_mean", Arity::Binary(), hash_mean_doc, &default_scalar_aggregate_options);
-    DCHECK_OK(AddHashAggKernels({boolean()}, GroupedMeanFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels(SignedIntTypes(), GroupedMeanFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(UnsignedIntTypes(), GroupedMeanFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(FloatingPointTypes(), GroupedMeanFactory::Make, func.get()));
-    // Type parameters are ignored
-    DCHECK_OK(AddHashAggKernels({decimal128(1, 1), decimal256(1, 1)},
-                                GroupedMeanFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels({null()}, GroupedMeanFactory::Make, func.get()));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_stddev", Arity::Binary(), hash_stddev_doc, &default_variance_options);
-    DCHECK_OK(AddHashAggregateStatisticKernels(
-        func.get(), MakeGroupedStatisticKernel<GroupedStddevImpl>));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_variance", Arity::Binary(), hash_variance_doc, &default_variance_options);
-    DCHECK_OK(AddHashAggregateStatisticKernels(
-        func.get(), MakeGroupedStatisticKernel<GroupedVarianceImpl>));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_skew", Arity::Binary(), hash_skew_doc, &default_skew_options);
+        "vendored_hash_skew", Arity::Binary(), hash_skew_doc, &default_skew_options);
     DCHECK_OK(AddHashAggregateStatisticKernels(
         func.get(), MakeGroupedStatisticKernel<GroupedSkewImpl>));
     DCHECK_OK(registry->AddFunction(std::move(func)));
@@ -4112,161 +4014,14 @@ void RegisterHashAggregateBasic(FunctionRegistry* registry) {
 
   {
     auto func = std::make_shared<HashAggregateFunction>(
-        "hash_kurtosis", Arity::Binary(), hash_kurtosis_doc, &default_skew_options);
+        "vendored_hash_kurtosis", Arity::Binary(), hash_kurtosis_doc, &default_skew_options);
     DCHECK_OK(AddHashAggregateStatisticKernels(
         func.get(), MakeGroupedStatisticKernel<GroupedKurtosisImpl>));
     DCHECK_OK(registry->AddFunction(std::move(func)));
   }
 
-  HashAggregateFunction* tdigest_func = nullptr;
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_tdigest", Arity::Binary(), hash_tdigest_doc, &default_tdigest_options);
-    DCHECK_OK(
-        AddHashAggKernels(SignedIntTypes(), GroupedTDigestFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(UnsignedIntTypes(), GroupedTDigestFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(FloatingPointTypes(), GroupedTDigestFactory::Make, func.get()));
-    // Type parameters are ignored
-    DCHECK_OK(AddHashAggKernels({decimal128(1, 1), decimal256(1, 1)},
-                                GroupedTDigestFactory::Make, func.get()));
-    tdigest_func = func.get();
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_approximate_median", Arity::Binary(), hash_approximate_median_doc,
-        &default_scalar_aggregate_options);
-    DCHECK_OK(func->AddKernel(MakeApproximateMedianKernel(tdigest_func)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  HashAggregateFunction* first_last_func = nullptr;
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_first_last", Arity::Binary(), hash_first_last_doc,
-        &default_scalar_aggregate_options);
-
-    DCHECK_OK(
-        AddHashAggKernels(NumericTypes(), GroupedFirstLastFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(TemporalTypes(), GroupedFirstLastFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(BaseBinaryTypes(), GroupedFirstLastFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels({boolean(), fixed_size_binary(1)},
-                                GroupedFirstLastFactory::Make, func.get()));
-
-    first_last_func = func.get();
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_first", Arity::Binary(), hash_first_doc, &default_scalar_aggregate_options);
-    DCHECK_OK(
-        func->AddKernel(MakeFirstOrLastKernel<FirstOrLast::First>(first_last_func)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_last", Arity::Binary(), hash_last_doc, &default_scalar_aggregate_options);
-    DCHECK_OK(func->AddKernel(MakeFirstOrLastKernel<FirstOrLast::Last>(first_last_func)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  HashAggregateFunction* min_max_func = nullptr;
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_min_max", Arity::Binary(), hash_min_max_doc,
-        &default_scalar_aggregate_options);
-    DCHECK_OK(AddHashAggKernels(NumericTypes(), GroupedMinMaxFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels(TemporalTypes(), GroupedMinMaxFactory::Make, func.get()));
-    DCHECK_OK(
-        AddHashAggKernels(BaseBinaryTypes(), GroupedMinMaxFactory::Make, func.get()));
-    // Type parameters are ignored
-    DCHECK_OK(AddHashAggKernels({null(), boolean(), decimal128(1, 1), decimal256(1, 1),
-                                 month_interval(), fixed_size_binary(1)},
-                                GroupedMinMaxFactory::Make, func.get()));
-    min_max_func = func.get();
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_min", Arity::Binary(), hash_min_or_max_doc,
-        &default_scalar_aggregate_options);
-    DCHECK_OK(func->AddKernel(MakeMinOrMaxKernel<MinOrMax::Min>(min_max_func)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_max", Arity::Binary(), hash_min_or_max_doc,
-        &default_scalar_aggregate_options);
-    DCHECK_OK(func->AddKernel(MakeMinOrMaxKernel<MinOrMax::Max>(min_max_func)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_any", Arity::Binary(), hash_any_doc, &default_scalar_aggregate_options);
-    DCHECK_OK(func->AddKernel(MakeKernel(boolean(), HashAggregateInit<GroupedAnyImpl>)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_all", Arity::Binary(), hash_all_doc, &default_scalar_aggregate_options);
-    DCHECK_OK(func->AddKernel(MakeKernel(boolean(), HashAggregateInit<GroupedAllImpl>)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_count_distinct", Arity::Binary(), hash_count_distinct_doc,
-        &default_count_options);
-    DCHECK_OK(func->AddKernel(
-        MakeKernel(InputType::Any(), GroupedDistinctInit<GroupedCountDistinctImpl>)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>(
-        "hash_distinct", Arity::Binary(), hash_distinct_doc, &default_count_options);
-    DCHECK_OK(func->AddKernel(
-        MakeKernel(InputType::Any(), GroupedDistinctInit<GroupedDistinctImpl>)));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>("hash_one", Arity::Binary(),
-                                                        hash_one_doc);
-    DCHECK_OK(AddHashAggKernels(NumericTypes(), GroupedOneFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels(TemporalTypes(), GroupedOneFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels(BaseBinaryTypes(), GroupedOneFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels({null(), boolean(), decimal128(1, 1), decimal256(1, 1),
-                                 month_interval(), fixed_size_binary(1)},
-                                GroupedOneFactory::Make, func.get()));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
-  {
-    auto func = std::make_shared<HashAggregateFunction>("hash_list", Arity::Binary(),
-                                                        hash_list_doc);
-    DCHECK_OK(AddHashAggKernels(NumericTypes(), GroupedListFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels(TemporalTypes(), GroupedListFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels(BaseBinaryTypes(), GroupedListFactory::Make, func.get()));
-    DCHECK_OK(AddHashAggKernels({null(), boolean(), decimal128(1, 1), decimal256(1, 1),
-                                 month_interval(), fixed_size_binary(1)},
-                                GroupedListFactory::Make, func.get()));
-    DCHECK_OK(registry->AddFunction(std::move(func)));
-  }
-
   {
-    auto func = std::make_shared<HashAggregateFunction>("hash_pivot_wider",
+    auto func = std::make_shared<HashAggregateFunction>("vendored_hash_pivot_wider",
                                                         Arity::Ternary(), hash_pivot_doc);
     for (auto key_type : BaseBinaryTypes()) {
       // Anything that scatter() (i.e. take()) accepts can be passed as values
@@ -4280,6 +4035,7 @@ void RegisterHashAggregateBasic(FunctionRegistry* registry) {
   }
 }
 
+}  // namespace vendored
 }  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/vector_rank.cc b/cpp/src/arrow/compute/kernels/vector_rank.cc
index d1323c2030..73c050d933 100644
--- a/cpp/src/arrow/compute/kernels/vector_rank.cc
+++ b/cpp/src/arrow/compute/kernels/vector_rank.cc
@@ -23,7 +23,7 @@
 #include "arrow/compute/registry.h"
 #include "arrow/util/math_internal.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 using ::arrow::util::span;
 
@@ -71,7 +71,7 @@ Result<NullPartitionResult> DoSortAndMarkDuplicate(
   using GetView = GetViewType<ArrowType>;
   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;
 
-  ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type));
+  ARROW_ASSIGN_OR_RAISE(auto array_sorter, arrow::compute::internal::GetArraySorter(*physical_type));
 
   ArrayType array(input.data());
   ARROW_ASSIGN_OR_RAISE(auto sorted,
@@ -380,7 +380,7 @@ class RankMetaFunction : public RankMetaFunctionBase<RankMetaFunction> {
   }
 
   RankMetaFunction()
-      : RankMetaFunctionBase("rank", Arity::Unary(), rank_doc, &kDefaultOptions) {}
+      : RankMetaFunctionBase("vendored_rank", Arity::Unary(), rank_doc, &kDefaultOptions) {}
 
   static inline const auto kDefaultOptions = RankOptions::Defaults();
 };
@@ -396,7 +396,7 @@ class RankQuantileMetaFunction : public RankMetaFunctionBase<RankQuantileMetaFun
   static RankerType GetRanker(const RankQuantileOptions& options) { return RankerType(); }
 
   RankQuantileMetaFunction()
-      : RankMetaFunctionBase("rank_quantile", Arity::Unary(), rank_quantile_doc,
+      : RankMetaFunctionBase("vendored_rank_quantile", Arity::Unary(), rank_quantile_doc,
                              &kDefaultOptions) {}
 
   static inline const auto kDefaultOptions = RankQuantileOptions::Defaults();
@@ -413,7 +413,7 @@ class RankNormalMetaFunction : public RankMetaFunctionBase<RankNormalMetaFunctio
   static RankerType GetRanker(const RankQuantileOptions& options) { return RankerType(); }
 
   RankNormalMetaFunction()
-      : RankMetaFunctionBase("rank_normal", Arity::Unary(), rank_normal_doc,
+      : RankMetaFunctionBase("vendored_rank_normal", Arity::Unary(), rank_normal_doc,
                              &kDefaultOptions) {}
 
   static inline const auto kDefaultOptions = RankQuantileOptions::Defaults();
@@ -427,4 +427,4 @@ void RegisterVectorRank(FunctionRegistry* registry) {
   DCHECK_OK(registry->AddFunction(std::make_shared<RankNormalMetaFunction>()));
 }
 
-}  // namespace arrow::compute::internal
+}  // namespace arrow::compute::internal::vendored
diff --git a/cpp/src/arrow/compute/kernels/vector_sort_internal.h b/cpp/src/arrow/compute/kernels/vector_sort_internal.h
index 6288aa26ea..fc03e187c6 100644
--- a/cpp/src/arrow/compute/kernels/vector_sort_internal.h
+++ b/cpp/src/arrow/compute/kernels/vector_sort_internal.h
@@ -31,6 +31,8 @@
 
 namespace arrow::compute::internal {
 
+namespace vendored {
+
 // Visit all physical types for which sorting is implemented.
 #define VISIT_SORTABLE_PHYSICAL_TYPES(VISIT) \
   VISIT(BooleanType)                         \
@@ -456,26 +458,6 @@ using MergeImpl = GenericMergeImpl<uint64_t, NullPartitionResult>;
 using ChunkedMergeImpl =
     GenericMergeImpl<CompressedChunkLocation, ChunkedNullPartitionResult>;
 
-// TODO make this usable if indices are non trivial on input
-// (see ConcreteRecordBatchColumnSorter)
-// `offset` is used when this is called on a chunk of a chunked array
-using ArraySortFunc = std::function<Result<NullPartitionResult>(
-    uint64_t* indices_begin, uint64_t* indices_end, const Array& values, int64_t offset,
-    const ArraySortOptions& options, ExecContext* ctx)>;
-
-Result<ArraySortFunc> GetArraySorter(const DataType& type);
-
-Result<NullPartitionResult> SortChunkedArray(ExecContext* ctx, uint64_t* indices_begin,
-                                             uint64_t* indices_end,
-                                             const ChunkedArray& chunked_array,
-                                             SortOrder sort_order,
-                                             NullPlacement null_placement);
-
-Result<NullPartitionResult> SortChunkedArray(
-    ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,
-    const std::shared_ptr<DataType>& physical_type, const ArrayVector& physical_chunks,
-    SortOrder sort_order, NullPlacement null_placement);
-
 Result<NullPartitionResult> SortStructArray(ExecContext* ctx, uint64_t* indices_begin,
                                             uint64_t* indices_end,
                                             const StructArray& array,
@@ -761,9 +743,9 @@ struct ResolvedTableSortKey {
         order(order),
         null_count(null_count) {}
 
-  using LocationType = ::arrow::ChunkLocation;
+  using LocationType = ::arrow::internal::ChunkLocation;
 
-  ResolvedChunk GetChunk(::arrow::ChunkLocation loc) const {
+  ResolvedChunk GetChunk(::arrow::internal::ChunkLocation loc) const {
     return {chunks[loc.chunk_index], loc.index_in_chunk};
   }
 
@@ -788,7 +770,7 @@ struct ResolvedTableSortKey {
                                   null_count);
     };
 
-    return ::arrow::compute::internal::ResolveSortKeys<ResolvedTableSortKey>(
+    return ::arrow::compute::internal::vendored::ResolveSortKeys<ResolvedTableSortKey>(
         *table.schema(), sort_keys, factory);
   }
 
@@ -813,4 +795,22 @@ inline Result<std::shared_ptr<ArrayData>> MakeMutableFloat64Array(
   return ArrayData::Make(float64(), length, {nullptr, std::move(data)}, /*null_count=*/0);
 }
 
+}  // namespace vendored
+// TODO make this usable if indices are non trivial on input
+// (see ConcreteRecordBatchColumnSorter)
+// `offset` is used when this is called on a chunk of a chunked array
+using ArraySortFunc = std::function<Result<vendored::NullPartitionResult>(
+  uint64_t* indices_begin, uint64_t* indices_end, const Array& values, int64_t offset,
+  const vendored::ArraySortOptions& options, ExecContext* ctx)>;
+Result<ArraySortFunc> GetArraySorter(const DataType& type);
+Result<vendored::NullPartitionResult> SortChunkedArray(ExecContext* ctx, uint64_t* indices_begin,
+  uint64_t* indices_end,
+  const ChunkedArray& chunked_array,
+  SortOrder sort_order,
+  NullPlacement null_placement);
+
+Result<vendored::NullPartitionResult> SortChunkedArray(
+ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,
+const std::shared_ptr<DataType>& physical_type, const ArrayVector& physical_chunks,
+SortOrder sort_order, NullPlacement null_placement);
 }  // namespace arrow::compute::internal
diff --git a/cpp/src/arrow/util/reflection_internal.h b/cpp/src/arrow/util/reflection_internal.h
index 5d281a265f..62cb2cda7b 100644
--- a/cpp/src/arrow/util/reflection_internal.h
+++ b/cpp/src/arrow/util/reflection_internal.h
@@ -26,6 +26,7 @@
 
 namespace arrow {
 namespace internal {
+namespace vendored {
 
 template <typename...>
 struct all_same : std::true_type {};
@@ -131,5 +132,6 @@ struct has_enum_traits : std::false_type {};
 template <typename T>
 struct has_enum_traits<T, void_t<typename EnumTraits<T>::Type>> : std::true_type {};
 
+}  // namespace vendored
 }  // namespace internal
 }  // namespace arrow
