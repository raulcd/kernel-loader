diff --git a/cpp/src/arrow/compute/api_aggregate.cc b/cpp/src/arrow/compute/api_aggregate.cc
index 4cd78a296a..e73500d817 100644
--- a/cpp/src/arrow/compute/api_aggregate.cc
+++ b/cpp/src/arrow/compute/api_aggregate.cc
@@ -25,19 +25,20 @@
 
 namespace arrow {
 namespace internal {
+namespace vendored {
 
 template <>
-struct EnumTraits<compute::CountOptions::CountMode>
-    : BasicEnumTraits<compute::CountOptions::CountMode, compute::CountOptions::ONLY_VALID,
-                      compute::CountOptions::ONLY_NULL, compute::CountOptions::ALL> {
+struct EnumTraits<compute::internal::vendored::CountOptions::CountMode>
+    : BasicEnumTraits<compute::internal::vendored::CountOptions::CountMode, compute::internal::vendored::CountOptions::ONLY_VALID,
+    compute::internal::vendored::CountOptions::ONLY_NULL, compute::internal::vendored::CountOptions::ALL> {
   static std::string name() { return "CountOptions::CountMode"; }
-  static std::string value_name(compute::CountOptions::CountMode value) {
+  static std::string value_name(compute::internal::vendored::CountOptions::CountMode value) {
     switch (value) {
-      case compute::CountOptions::ONLY_VALID:
+      case compute::internal::vendored::CountOptions::ONLY_VALID:
         return "NON_NULL";
-      case compute::CountOptions::ONLY_NULL:
+      case compute::internal::vendored::CountOptions::ONLY_NULL:
         return "NULLS";
-      case compute::CountOptions::ALL:
+      case compute::internal::vendored::CountOptions::ALL:
         return "ALL";
     }
     return "<INVALID>";
@@ -45,23 +46,23 @@ struct EnumTraits<compute::CountOptions::CountMode>
 };
 
 template <>
-struct EnumTraits<compute::QuantileOptions::Interpolation>
-    : BasicEnumTraits<compute::QuantileOptions::Interpolation,
-                      compute::QuantileOptions::LINEAR, compute::QuantileOptions::LOWER,
-                      compute::QuantileOptions::HIGHER, compute::QuantileOptions::NEAREST,
-                      compute::QuantileOptions::MIDPOINT> {
+struct EnumTraits<compute::internal::vendored::QuantileOptions::Interpolation>
+    : BasicEnumTraits<compute::internal::vendored::QuantileOptions::Interpolation,
+                      compute::internal::vendored::QuantileOptions::LINEAR, compute::internal::vendored::QuantileOptions::LOWER,
+                      compute::internal::vendored::QuantileOptions::HIGHER, compute::internal::vendored::QuantileOptions::NEAREST,
+                      compute::internal::vendored::QuantileOptions::MIDPOINT> {
   static std::string name() { return "QuantileOptions::Interpolation"; }
-  static std::string value_name(compute::QuantileOptions::Interpolation value) {
+  static std::string value_name(compute::internal::vendored::QuantileOptions::Interpolation value) {
     switch (value) {
-      case compute::QuantileOptions::LINEAR:
+      case compute::internal::vendored::QuantileOptions::LINEAR:
         return "LINEAR";
-      case compute::QuantileOptions::LOWER:
+      case compute::internal::vendored::QuantileOptions::LOWER:
         return "LOWER";
-      case compute::QuantileOptions::HIGHER:
+      case compute::internal::vendored::QuantileOptions::HIGHER:
         return "HIGHER";
-      case compute::QuantileOptions::NEAREST:
+      case compute::internal::vendored::QuantileOptions::NEAREST:
         return "NEAREST";
-      case compute::QuantileOptions::MIDPOINT:
+      case compute::internal::vendored::QuantileOptions::MIDPOINT:
         return "MIDPOINT";
     }
     return "<INVALID>";
@@ -69,22 +70,22 @@ struct EnumTraits<compute::QuantileOptions::Interpolation>
 };
 
 template <>
-struct EnumTraits<compute::PivotWiderOptions::UnexpectedKeyBehavior>
-    : BasicEnumTraits<compute::PivotWiderOptions::UnexpectedKeyBehavior,
-                      compute::PivotWiderOptions::kIgnore,
-                      compute::PivotWiderOptions::kRaise> {
+struct EnumTraits<compute::internal::vendored::PivotWiderOptions::UnexpectedKeyBehavior>
+    : BasicEnumTraits<compute::internal::vendored::PivotWiderOptions::UnexpectedKeyBehavior,
+                      compute::internal::vendored::PivotWiderOptions::kIgnore,
+                      compute::internal::vendored::PivotWiderOptions::kRaise> {
   static std::string name() { return "PivotWiderOptions::UnexpectedKeyBehavior"; }
-  static std::string value_name(compute::PivotWiderOptions::UnexpectedKeyBehavior value) {
+  static std::string value_name(compute::internal::vendored::PivotWiderOptions::UnexpectedKeyBehavior value) {
     switch (value) {
-      case compute::PivotWiderOptions::kIgnore:
+      case compute::internal::vendored::PivotWiderOptions::kIgnore:
         return "kIgnore";
-      case compute::PivotWiderOptions::kRaise:
+      case compute::internal::vendored::PivotWiderOptions::kRaise:
         return "kRaise";
     }
     return "<INVALID>";
   }
 };
-
+}  // namespace vendored
 }  // namespace internal
 
 namespace compute {
@@ -94,9 +95,9 @@ namespace compute {
 
 using ::arrow::internal::checked_cast;
 
-namespace internal {
+namespace internal::vendored {
 namespace {
-using ::arrow::internal::DataMember;
+using ::arrow::internal::vendored::DataMember;
 static auto kScalarAggregateOptionsType = GetFunctionOptionsType<ScalarAggregateOptions>(
     DataMember("skip_nulls", &ScalarAggregateOptions::skip_nulls),
     DataMember("min_count", &ScalarAggregateOptions::min_count));
@@ -129,48 +130,47 @@ static auto kPivotOptionsType = GetFunctionOptionsType<PivotWiderOptions>(
 static auto kIndexOptionsType =
     GetFunctionOptionsType<IndexOptions>(DataMember("value", &IndexOptions::value));
 }  // namespace
-}  // namespace internal
 
 ScalarAggregateOptions::ScalarAggregateOptions(bool skip_nulls, uint32_t min_count)
-    : FunctionOptions(internal::kScalarAggregateOptionsType),
+    : FunctionOptions(kScalarAggregateOptionsType),
       skip_nulls(skip_nulls),
       min_count(min_count) {}
 constexpr char ScalarAggregateOptions::kTypeName[];
 
 CountOptions::CountOptions(CountMode mode)
-    : FunctionOptions(internal::kCountOptionsType), mode(mode) {}
+    : FunctionOptions(kCountOptionsType), mode(mode) {}
 constexpr char CountOptions::kTypeName[];
 
 ModeOptions::ModeOptions(int64_t n, bool skip_nulls, uint32_t min_count)
-    : FunctionOptions(internal::kModeOptionsType),
+    : FunctionOptions(kModeOptionsType),
       n{n},
       skip_nulls{skip_nulls},
       min_count{min_count} {}
 constexpr char ModeOptions::kTypeName[];
 
 VarianceOptions::VarianceOptions(int ddof, bool skip_nulls, uint32_t min_count)
-    : FunctionOptions(internal::kVarianceOptionsType),
+    : FunctionOptions(kVarianceOptionsType),
       ddof(ddof),
       skip_nulls(skip_nulls),
       min_count(min_count) {}
 constexpr char VarianceOptions::kTypeName[];
 
 SkewOptions::SkewOptions(bool skip_nulls, bool biased, uint32_t min_count)
-    : FunctionOptions(internal::kSkewOptionsType),
+    : FunctionOptions(kSkewOptionsType),
       skip_nulls(skip_nulls),
       biased(biased),
       min_count(min_count) {}
 
 QuantileOptions::QuantileOptions(double q, enum Interpolation interpolation,
                                  bool skip_nulls, uint32_t min_count)
-    : FunctionOptions(internal::kQuantileOptionsType),
+    : FunctionOptions(kQuantileOptionsType),
       q{q},
       interpolation{interpolation},
       skip_nulls{skip_nulls},
       min_count{min_count} {}
 QuantileOptions::QuantileOptions(std::vector<double> q, enum Interpolation interpolation,
                                  bool skip_nulls, uint32_t min_count)
-    : FunctionOptions(internal::kQuantileOptionsType),
+    : FunctionOptions(kQuantileOptionsType),
       q{std::move(q)},
       interpolation{interpolation},
       skip_nulls{skip_nulls},
@@ -179,7 +179,7 @@ constexpr char QuantileOptions::kTypeName[];
 
 TDigestOptions::TDigestOptions(double q, uint32_t delta, uint32_t buffer_size,
                                bool skip_nulls, uint32_t min_count)
-    : FunctionOptions(internal::kTDigestOptionsType),
+    : FunctionOptions(kTDigestOptionsType),
       q{q},
       delta{delta},
       buffer_size{buffer_size},
@@ -187,7 +187,7 @@ TDigestOptions::TDigestOptions(double q, uint32_t delta, uint32_t buffer_size,
       min_count{min_count} {}
 TDigestOptions::TDigestOptions(std::vector<double> q, uint32_t delta,
                                uint32_t buffer_size, bool skip_nulls, uint32_t min_count)
-    : FunctionOptions(internal::kTDigestOptionsType),
+    : FunctionOptions(kTDigestOptionsType),
       q{std::move(q)},
       delta{delta},
       buffer_size{buffer_size},
@@ -197,17 +197,16 @@ constexpr char TDigestOptions::kTypeName[];
 
 PivotWiderOptions::PivotWiderOptions(std::vector<std::string> key_names,
                                      UnexpectedKeyBehavior unexpected_key_behavior)
-    : FunctionOptions(internal::kPivotOptionsType),
+    : FunctionOptions(kPivotOptionsType),
       key_names(std::move(key_names)),
       unexpected_key_behavior(unexpected_key_behavior) {}
-PivotWiderOptions::PivotWiderOptions() : FunctionOptions(internal::kPivotOptionsType) {}
+PivotWiderOptions::PivotWiderOptions() : FunctionOptions(kPivotOptionsType) {}
 
 IndexOptions::IndexOptions(std::shared_ptr<Scalar> value)
-    : FunctionOptions(internal::kIndexOptionsType), value{std::move(value)} {}
+    : FunctionOptions(kIndexOptionsType), value{std::move(value)} {}
 IndexOptions::IndexOptions() : IndexOptions(std::make_shared<NullScalar>()) {}
 constexpr char IndexOptions::kTypeName[];
 
-namespace internal {
 void RegisterAggregateOptions(FunctionRegistry* registry) {
   DCHECK_OK(registry->AddFunctionOptionsType(kScalarAggregateOptionsType));
   DCHECK_OK(registry->AddFunctionOptionsType(kCountOptionsType));
@@ -219,7 +218,6 @@ void RegisterAggregateOptions(FunctionRegistry* registry) {
   DCHECK_OK(registry->AddFunctionOptionsType(kPivotOptionsType));
   DCHECK_OK(registry->AddFunctionOptionsType(kIndexOptionsType));
 }
-}  // namespace internal
 
 // ----------------------------------------------------------------------
 // Scalar aggregates
@@ -304,5 +302,6 @@ Result<Datum> Index(const Datum& value, const IndexOptions& options, ExecContext
   return CallFunction("index", {value}, &options, ctx);
 }
 
+}  // namespace internal::vendored
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/api_aggregate.h b/cpp/src/arrow/compute/api_aggregate.h
index 1d9076f6ba..3603975576 100644
--- a/cpp/src/arrow/compute/api_aggregate.h
+++ b/cpp/src/arrow/compute/api_aggregate.h
@@ -36,6 +36,7 @@ namespace compute {
 
 class ExecContext;
 
+namespace internal::vendored {
 // ----------------------------------------------------------------------
 // Aggregate functions
 
@@ -590,6 +591,6 @@ Result<Datum> TDigest(const Datum& value,
 ARROW_EXPORT
 Result<Datum> Index(const Datum& value, const IndexOptions& options,
                     ExecContext* ctx = NULLPTR);
-
+}  // namespace internal::vendored
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/api_vector.cc b/cpp/src/arrow/compute/api_vector.cc
index 012e403e70..05e58e4f21 100644
--- a/cpp/src/arrow/compute/api_vector.cc
+++ b/cpp/src/arrow/compute/api_vector.cc
@@ -42,13 +42,13 @@ namespace arrow {
 using internal::checked_cast;
 using internal::checked_pointer_cast;
 
-namespace internal {
+namespace internal::vendored {
 
-using compute::DictionaryEncodeOptions;
-using compute::FilterOptions;
+using compute::internal::vendored::DictionaryEncodeOptions;
+using compute::internal::vendored::FilterOptions;
 using compute::NullPlacement;
-using compute::RankOptions;
-using compute::RankQuantileOptions;
+using compute::internal::vendored::RankOptions;
+using compute::internal::vendored::RankQuantileOptions;
 
 template <>
 struct EnumTraits<FilterOptions::NullSelectionBehavior>
@@ -122,8 +122,9 @@ namespace compute {
 // Function options
 
 namespace internal {
+namespace vendored {
 namespace {
-using ::arrow::internal::DataMember;
+using ::arrow::internal::vendored::DataMember;
 static auto kFilterOptionsType = GetFunctionOptionsType<FilterOptions>(
     DataMember("null_selection_behavior", &FilterOptions::null_selection_behavior));
 static auto kTakeOptionsType = GetFunctionOptionsType<TakeOptions>(
@@ -169,72 +170,71 @@ static auto kInversePermutationOptionsType =
 static auto kScatterOptionsType = GetFunctionOptionsType<ScatterOptions>(
     DataMember("max_index", &ScatterOptions::max_index));
 }  // namespace
-}  // namespace internal
 
 FilterOptions::FilterOptions(NullSelectionBehavior null_selection)
-    : FunctionOptions(internal::kFilterOptionsType),
+    : FunctionOptions(kFilterOptionsType),
       null_selection_behavior(null_selection) {}
 constexpr char FilterOptions::kTypeName[];
 
 TakeOptions::TakeOptions(bool boundscheck)
-    : FunctionOptions(internal::kTakeOptionsType), boundscheck(boundscheck) {}
+    : FunctionOptions(kTakeOptionsType), boundscheck(boundscheck) {}
 constexpr char TakeOptions::kTypeName[];
 
 DictionaryEncodeOptions::DictionaryEncodeOptions(NullEncodingBehavior null_encoding)
-    : FunctionOptions(internal::kDictionaryEncodeOptionsType),
+    : FunctionOptions(kDictionaryEncodeOptionsType),
       null_encoding_behavior(null_encoding) {}
 constexpr char DictionaryEncodeOptions::kTypeName[];
 
 RunEndEncodeOptions::RunEndEncodeOptions(std::shared_ptr<DataType> run_end_type)
-    : FunctionOptions(internal::kRunEndEncodeOptionsType),
+    : FunctionOptions(kRunEndEncodeOptionsType),
       run_end_type{std::move(run_end_type)} {}
 
 ArraySortOptions::ArraySortOptions(SortOrder order, NullPlacement null_placement)
-    : FunctionOptions(internal::kArraySortOptionsType),
+    : FunctionOptions(kArraySortOptionsType),
       order(order),
       null_placement(null_placement) {}
 constexpr char ArraySortOptions::kTypeName[];
 
 SortOptions::SortOptions(std::vector<SortKey> sort_keys, NullPlacement null_placement)
-    : FunctionOptions(internal::kSortOptionsType),
+    : FunctionOptions(kSortOptionsType),
       sort_keys(std::move(sort_keys)),
       null_placement(null_placement) {}
 SortOptions::SortOptions(const Ordering& ordering)
-    : FunctionOptions(internal::kSortOptionsType),
+    : FunctionOptions(kSortOptionsType),
       sort_keys(ordering.sort_keys()),
       null_placement(ordering.null_placement()) {}
 constexpr char SortOptions::kTypeName[];
 
 PartitionNthOptions::PartitionNthOptions(int64_t pivot, NullPlacement null_placement)
-    : FunctionOptions(internal::kPartitionNthOptionsType),
+    : FunctionOptions(kPartitionNthOptionsType),
       pivot(pivot),
       null_placement(null_placement) {}
 constexpr char PartitionNthOptions::kTypeName[];
 
 WinsorizeOptions::WinsorizeOptions(double lower_limit, double upper_limit)
-    : FunctionOptions(internal::kWinsorizeOptionsType),
+    : FunctionOptions(kWinsorizeOptionsType),
       lower_limit(lower_limit),
       upper_limit(upper_limit) {}
 
 SelectKOptions::SelectKOptions(int64_t k, std::vector<SortKey> sort_keys)
-    : FunctionOptions(internal::kSelectKOptionsType),
+    : FunctionOptions(kSelectKOptionsType),
       k(k),
       sort_keys(std::move(sort_keys)) {}
 constexpr char SelectKOptions::kTypeName[];
 
 CumulativeOptions::CumulativeOptions(bool skip_nulls)
-    : FunctionOptions(internal::kCumulativeOptionsType), skip_nulls(skip_nulls) {}
+    : FunctionOptions(kCumulativeOptionsType), skip_nulls(skip_nulls) {}
 CumulativeOptions::CumulativeOptions(double start, bool skip_nulls)
     : CumulativeOptions(std::make_shared<DoubleScalar>(start), skip_nulls) {}
 CumulativeOptions::CumulativeOptions(std::shared_ptr<Scalar> start, bool skip_nulls)
-    : FunctionOptions(internal::kCumulativeOptionsType),
+    : FunctionOptions(kCumulativeOptionsType),
       start(std::move(start)),
       skip_nulls(skip_nulls) {}
 constexpr char CumulativeOptions::kTypeName[];
 
 RankOptions::RankOptions(std::vector<SortKey> sort_keys, NullPlacement null_placement,
                          RankOptions::Tiebreaker tiebreaker)
-    : FunctionOptions(internal::kRankOptionsType),
+    : FunctionOptions(kRankOptionsType),
       sort_keys(std::move(sort_keys)),
       null_placement(null_placement),
       tiebreaker(tiebreaker) {}
@@ -242,28 +242,28 @@ constexpr char RankOptions::kTypeName[];
 
 RankQuantileOptions::RankQuantileOptions(std::vector<SortKey> sort_keys,
                                          NullPlacement null_placement)
-    : FunctionOptions(internal::kRankQuantileOptionsType),
+    : FunctionOptions(kRankQuantileOptionsType),
       sort_keys(std::move(sort_keys)),
       null_placement(null_placement) {}
 constexpr char RankQuantileOptions::kTypeName[];
 
 PairwiseOptions::PairwiseOptions(int64_t periods)
-    : FunctionOptions(internal::kPairwiseOptionsType), periods(periods) {}
+    : FunctionOptions(kPairwiseOptionsType), periods(periods) {}
 constexpr char PairwiseOptions::kTypeName[];
 
 ListFlattenOptions::ListFlattenOptions(bool recursive)
-    : FunctionOptions(internal::kListFlattenOptionsType), recursive(recursive) {}
+    : FunctionOptions(kListFlattenOptionsType), recursive(recursive) {}
 constexpr char ListFlattenOptions::kTypeName[];
 
 InversePermutationOptions::InversePermutationOptions(
     int64_t max_index, std::shared_ptr<DataType> output_type)
-    : FunctionOptions(internal::kInversePermutationOptionsType),
+    : FunctionOptions(kInversePermutationOptionsType),
       max_index(max_index),
       output_type(std::move(output_type)) {}
 constexpr char InversePermutationOptions::kTypeName[];
 
 ScatterOptions::ScatterOptions(int64_t max_index)
-    : FunctionOptions(internal::kScatterOptionsType), max_index(max_index) {}
+    : FunctionOptions(kScatterOptionsType), max_index(max_index) {}
 constexpr char ScatterOptions::kTypeName[];
 
 namespace internal {
@@ -482,6 +482,7 @@ Result<Datum> Scatter(const Datum& values, const Datum& indices,
                       const ScatterOptions& options, ExecContext* ctx) {
   return CallFunction("scatter", {values, indices}, &options, ctx);
 }
-
+}  // namespace vendored
+}  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/api_vector.h b/cpp/src/arrow/compute/api_vector.h
index 69e4b243c9..6fd7c62431 100644
--- a/cpp/src/arrow/compute/api_vector.h
+++ b/cpp/src/arrow/compute/api_vector.h
@@ -30,6 +30,8 @@ namespace compute {
 
 class ExecContext;
 
+namespace internal::vendored {
+
 /// \addtogroup compute-concrete-options
 /// @{
 
@@ -830,5 +832,6 @@ Result<Datum> Scatter(const Datum& values, const Datum& indices,
                       const ScatterOptions& options = ScatterOptions::Defaults(),
                       ExecContext* ctx = NULLPTR);
 
+}  // namespace internal::vendored
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/function_internal.cc b/cpp/src/arrow/compute/function_internal.cc
index 8d85254209..a8d66216e3 100644
--- a/cpp/src/arrow/compute/function_internal.cc
+++ b/cpp/src/arrow/compute/function_internal.cc
@@ -34,6 +34,7 @@
 namespace arrow {
 namespace compute {
 namespace internal {
+namespace vendored {
 using ::arrow::internal::checked_cast;
 
 constexpr char kTypeNameField[] = "_type_name";
@@ -143,6 +144,7 @@ Result<std::vector<TypeHolder>> GetFunctionArgumentTypes(const std::vector<Datum
   return inputs;
 }
 
+}  // namespace vendored
 }  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/function_internal.h b/cpp/src/arrow/compute/function_internal.h
index 9d8928466b..5e102409d6 100644
--- a/cpp/src/arrow/compute/function_internal.h
+++ b/cpp/src/arrow/compute/function_internal.h
@@ -42,6 +42,7 @@ struct StructScalar;
 using ::arrow::internal::checked_cast;
 
 namespace internal {
+namespace vendored {
 template <>
 struct EnumTraits<compute::SortOrder>
     : BasicEnumTraits<compute::SortOrder, compute::SortOrder::Ascending,
@@ -57,13 +58,15 @@ struct EnumTraits<compute::SortOrder>
     return "<INVALID>";
   }
 };
+}  // namespace vendored
 }  // namespace internal
 
 namespace compute {
 namespace internal {
+namespace vendored {
 
-using arrow::internal::EnumTraits;
-using arrow::internal::has_enum_traits;
+using arrow::internal::vendored::EnumTraits;
+using arrow::internal::vendored::has_enum_traits;
 
 template <typename Enum, typename CType = typename std::underlying_type<Enum>::type>
 Result<Enum> ValidateEnumValue(CType raw) {
@@ -656,7 +659,7 @@ template <typename Options, typename... Properties>
 const FunctionOptionsType* GetFunctionOptionsType(const Properties&... properties) {
   static const class OptionsType : public GenericOptionsType {
    public:
-    explicit OptionsType(const arrow::internal::PropertyTuple<Properties...> properties)
+    explicit OptionsType(const arrow::internal::vendored::PropertyTuple<Properties...> properties)
         : properties_(properties) {}
 
     const char* type_name() const override { return Options::kTypeName; }
@@ -694,8 +697,8 @@ const FunctionOptionsType* GetFunctionOptionsType(const Properties&... propertie
     }
 
    private:
-    const arrow::internal::PropertyTuple<Properties...> properties_;
-  } instance(arrow::internal::MakeProperties(properties...));
+    const arrow::internal::vendored::PropertyTuple<Properties...> properties_;
+  } instance(arrow::internal::vendored::MakeProperties(properties...));
   return &instance;
 }
 
@@ -704,6 +707,7 @@ Status CheckAllArrayOrScalar(const std::vector<Datum>& values);
 ARROW_EXPORT
 Result<std::vector<TypeHolder>> GetFunctionArgumentTypes(const std::vector<Datum>& args);
 
+}  // namespace vendored
 }  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/aggregate_basic.cc b/cpp/src/arrow/compute/kernels/aggregate_basic.cc
index 68b1ac7c03..b506d54437 100644
--- a/cpp/src/arrow/compute/kernels/aggregate_basic.cc
+++ b/cpp/src/arrow/compute/kernels/aggregate_basic.cc
@@ -30,6 +30,7 @@
 namespace arrow {
 namespace compute {
 namespace internal {
+namespace vendored {
 
 namespace {
 
@@ -305,7 +306,7 @@ Result<std::unique_ptr<KernelState>> MeanInit(KernelContext* ctx,
 // ----------------------------------------------------------------------
 // Product implementation
 
-using arrow::compute::internal::to_unsigned;
+using arrow::compute::internal::vendored::to_unsigned;
 
 template <typename ArrowType>
 struct ProductImpl : public ScalarAggregator {
@@ -333,7 +334,7 @@ struct ProductImpl : public ScalarAggregator {
         return Status::OK();
       }
 
-      internal::VisitArrayValuesInline<ArrowType>(
+      internal::vendored::VisitArrayValuesInline<ArrowType>(
           data,
           [&](typename TypeTraits<ArrowType>::CType value) {
             this->product = MultiplyTraits<AccType>::Multiply(
@@ -346,7 +347,7 @@ struct ProductImpl : public ScalarAggregator {
       this->nulls_observed = this->nulls_observed || !data.is_valid;
       if (data.is_valid) {
         for (int64_t i = 0; i < batch.length; i++) {
-          auto value = internal::UnboxScalar<ArrowType>::Unbox(data);
+          auto value = internal::vendored::UnboxScalar<ArrowType>::Unbox(data);
           this->product = MultiplyTraits<AccType>::Multiply(
               *out_type, this->product, static_cast<ProductType>(value));
         }
@@ -666,7 +667,7 @@ Result<std::unique_ptr<KernelState>> AllInit(KernelContext*, const KernelInitArg
 
 template <typename ArgType>
 struct IndexImpl : public ScalarAggregator {
-  using ArgValue = typename internal::GetViewType<ArgType>::T;
+  using ArgValue = typename internal::vendored::GetViewType<ArgType>::T;
 
   explicit IndexImpl(IndexOptions options, KernelState* raw_state)
       : options(std::move(options)), seen(0), index(-1) {
@@ -682,12 +683,12 @@ struct IndexImpl : public ScalarAggregator {
       return Status::OK();
     }
 
-    const ArgValue desired = internal::UnboxScalar<ArgType>::Unbox(*options.value);
+    const ArgValue desired = internal::vendored::UnboxScalar<ArgType>::Unbox(*options.value);
 
     if (batch[0].is_scalar()) {
       seen = batch.length;
       if (batch[0].scalar->is_valid) {
-        const ArgValue v = internal::UnboxScalar<ArgType>::Unbox(*batch[0].scalar);
+        const ArgValue v = internal::vendored::UnboxScalar<ArgType>::Unbox(*batch[0].scalar);
         if (v == desired) {
           index = 0;
           return Status::Cancelled("Found");
@@ -700,7 +701,7 @@ struct IndexImpl : public ScalarAggregator {
     seen = input.length;
     int64_t i = 0;
 
-    ARROW_UNUSED(internal::VisitArrayValuesInline<ArgType>(
+    ARROW_UNUSED(internal::vendored::VisitArrayValuesInline<ArgType>(
         input,
         [&](ArgValue v) -> Status {
           if (v == desired) {
@@ -885,7 +886,7 @@ Result<TypeHolder> FirstLastType(KernelContext*, const std::vector<TypeHolder>&
   return struct_({field("first", ty), field("last", ty)});
 }
 
-void AddFirstLastKernel(KernelInit init, internal::detail::GetTypeId get_id,
+void AddFirstLastKernel(KernelInit init, internal::vendored::detail::GetTypeId get_id,
                         ScalarAggregateFunction* func, SimdLevel::type simd_level) {
   auto sig = KernelSignature::Make({InputType(get_id.id)}, FirstLastType);
   AddAggKernel(std::move(sig), init, func, simd_level);
@@ -899,7 +900,7 @@ void AddFirstLastKernels(KernelInit init,
   }
 }
 
-void AddMinMaxKernel(KernelInit init, internal::detail::GetTypeId get_id,
+void AddMinMaxKernel(KernelInit init, internal::vendored::detail::GetTypeId get_id,
                      ScalarAggregateFunction* func, SimdLevel::type simd_level) {
   auto sig = KernelSignature::Make({InputType(get_id.id)}, MinMaxType);
   AddAggKernel(std::move(sig), init, func, simd_level);
@@ -1190,6 +1191,7 @@ void RegisterScalarAggregateBasic(FunctionRegistry* registry) {
   DCHECK_OK(registry->AddFunction(std::move(func)));
 }
 
+}  // namespace vendored
 }  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/aggregate_basic.inc.cc b/cpp/src/arrow/compute/kernels/aggregate_basic.inc.cc
index 49010d182c..496f26003d 100644
--- a/cpp/src/arrow/compute/kernels/aggregate_basic.inc.cc
+++ b/cpp/src/arrow/compute/kernels/aggregate_basic.inc.cc
@@ -38,7 +38,7 @@
 #include "arrow/util/bit_block_counter.h"
 #include "arrow/util/decimal.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 namespace {
 
 // ----------------------------------------------------------------------
@@ -77,7 +77,7 @@ struct SumImpl : public ScalarAggregator {
       this->count += data.is_valid * batch.length;
       this->nulls_observed = this->nulls_observed || !data.is_valid;
       if (data.is_valid) {
-        this->sum += static_cast<SumCType>(internal::UnboxScalar<ArrowType>::Unbox(data) *
+        this->sum += static_cast<SumCType>(internal::vendored::UnboxScalar<ArrowType>::Unbox(data) *
                                            batch.length);
       }
     }
@@ -445,7 +445,7 @@ struct FirstLastImpl : public ScalarAggregator {
   Status ConsumeScalar(const Scalar& scalar) {
     this->state.has_any_values = true;
     if (scalar.is_valid) {
-      this->state.MergeOne(internal::UnboxScalar<ArrowType>::Unbox(scalar));
+      this->state.MergeOne(internal::vendored::UnboxScalar<ArrowType>::Unbox(scalar));
     } else {
       if (!this->state.has_values) {
         this->state.first_is_null = true;
@@ -778,7 +778,7 @@ struct MinMaxImpl : public ScalarAggregator {
     this->count += scalar.is_valid;
 
     if (!local.has_nulls || options.skip_nulls) {
-      local.MergeOne(internal::UnboxScalar<ArrowType>::Unbox(scalar));
+      local.MergeOne(internal::vendored::UnboxScalar<ArrowType>::Unbox(scalar));
     }
 
     this->state += local;
diff --git a/cpp/src/arrow/compute/kernels/aggregate_basic_internal.h b/cpp/src/arrow/compute/kernels/aggregate_basic_internal.h
index 5cc3a558b1..1908015d24 100644
--- a/cpp/src/arrow/compute/kernels/aggregate_basic_internal.h
+++ b/cpp/src/arrow/compute/kernels/aggregate_basic_internal.h
@@ -25,7 +25,7 @@
 #include "arrow/compute/type_fwd.h"
 #include "arrow/type_fwd.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 // aggregate_basic.cc
 
@@ -38,7 +38,7 @@ void AddMinMaxKernels(KernelInit init,
                       const std::vector<std::shared_ptr<DataType>>& types,
                       ScalarAggregateFunction* func,
                       SimdLevel::type simd_level = SimdLevel::NONE);
-void AddMinMaxKernel(KernelInit init, internal::detail::GetTypeId get_id,
+void AddMinMaxKernel(KernelInit init, detail::GetTypeId get_id,
                      ScalarAggregateFunction* func,
                      SimdLevel::type simd_level = SimdLevel::NONE);
 
diff --git a/cpp/src/arrow/compute/kernels/aggregate_internal.h b/cpp/src/arrow/compute/kernels/aggregate_internal.h
index 23aa20eddc..6425821399 100644
--- a/cpp/src/arrow/compute/kernels/aggregate_internal.h
+++ b/cpp/src/arrow/compute/kernels/aggregate_internal.h
@@ -27,7 +27,7 @@
 #include "arrow/util/int128_internal.h"
 #include "arrow/util/logging.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 // Find the largest compatible primitive type for a primitive type.
 template <typename I, typename Enable = void>
@@ -82,7 +82,7 @@ struct MultiplyTraits {
   constexpr static CType one(const DataType&) { return static_cast<CType>(1); }
 
   constexpr static CType Multiply(const DataType&, CType lhs, CType rhs) {
-    return static_cast<CType>(internal::to_unsigned(lhs) * internal::to_unsigned(rhs));
+    return static_cast<CType>(to_unsigned(lhs) * to_unsigned(rhs));
   }
 };
 
diff --git a/cpp/src/arrow/compute/kernels/aggregate_pivot.cc b/cpp/src/arrow/compute/kernels/aggregate_pivot.cc
index 3ff6327ec9..bfa66cc696 100644
--- a/cpp/src/arrow/compute/kernels/aggregate_pivot.cc
+++ b/cpp/src/arrow/compute/kernels/aggregate_pivot.cc
@@ -23,7 +23,7 @@
 #include "arrow/util/bit_run_reader.h"
 #include "arrow/util/logging.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 namespace {
 
 using arrow::internal::VisitSetBitRunsVoid;
@@ -178,7 +178,7 @@ void RegisterScalarAggregatePivot(FunctionRegistry* registry) {
   static auto default_pivot_options = PivotWiderOptions::Defaults();
 
   auto func = std::make_shared<ScalarAggregateFunction>(
-      "pivot_wider", Arity::Binary(), pivot_doc, &default_pivot_options);
+      "vendored_pivot_wider", Arity::Binary(), pivot_doc, &default_pivot_options);
 
   for (auto key_type : BaseBinaryTypes()) {
     auto sig = KernelSignature::Make({key_type->id(), InputType::Any()},
diff --git a/cpp/src/arrow/compute/kernels/chunked_internal.cc b/cpp/src/arrow/compute/kernels/chunked_internal.cc
index e72b8e1f5b..abddc53f96 100644
--- a/cpp/src/arrow/compute/kernels/chunked_internal.cc
+++ b/cpp/src/arrow/compute/kernels/chunked_internal.cc
@@ -22,7 +22,7 @@
 #include "arrow/record_batch.h"
 #include "arrow/util/logging.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 std::vector<const Array*> GetArrayPointers(const ArrayVector& arrays) {
   std::vector<const Array*> pointers(arrays.size());
@@ -119,4 +119,4 @@ Status ChunkedIndexMapper::PhysicalToLogical() {
   return Status::OK();
 }
 
-}  // namespace arrow::compute::internal
+}  // namespace arrow::compute::internal::vendored
diff --git a/cpp/src/arrow/compute/kernels/chunked_internal.h b/cpp/src/arrow/compute/kernels/chunked_internal.h
index 5bc8233016..916f02957e 100644
--- a/cpp/src/arrow/compute/kernels/chunked_internal.h
+++ b/cpp/src/arrow/compute/kernels/chunked_internal.h
@@ -28,7 +28,7 @@
 #include "arrow/compute/kernels/codegen_internal.h"
 #include "arrow/util/span.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 // The target chunk in a chunked array.
 struct ResolvedChunk {
diff --git a/cpp/src/arrow/compute/kernels/codegen_internal.cc b/cpp/src/arrow/compute/kernels/codegen_internal.cc
index 0fd9cae7a8..c7f8c30b74 100644
--- a/cpp/src/arrow/compute/kernels/codegen_internal.cc
+++ b/cpp/src/arrow/compute/kernels/codegen_internal.cc
@@ -29,6 +29,7 @@
 namespace arrow {
 namespace compute {
 namespace internal {
+namespace vendored {
 
 const std::vector<std::shared_ptr<DataType>>& ExampleParametricTypes() {
   static DataTypeVector example_parametric_types = {
@@ -551,6 +552,7 @@ void PromoteIntegerForDurationArithmetic(std::vector<TypeHolder>* types) {
   }
 }
 
+}  // namespace vendored
 }  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/codegen_internal.h b/cpp/src/arrow/compute/kernels/codegen_internal.h
index 1d49579a5a..71863a2319 100644
--- a/cpp/src/arrow/compute/kernels/codegen_internal.h
+++ b/cpp/src/arrow/compute/kernels/codegen_internal.h
@@ -63,6 +63,7 @@ using internal::VisitTwoBitBlocksVoid;
 
 namespace compute {
 namespace internal {
+namespace vendored {
 
 /// KernelState adapter for the common case of kernels whose only
 /// state is an instance of a subclass of FunctionOptions.
@@ -1450,6 +1451,7 @@ void PromoteIntegerForDurationArithmetic(std::vector<TypeHolder>* types);
 
 // END of DispatchBest helpers
 // ----------------------------------------------------------------------
+}  // namespace vendored
 }  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/hash_aggregate_internal.h b/cpp/src/arrow/compute/kernels/hash_aggregate_internal.h
index 9ea4cdfcc5..ff6b2cb840 100644
--- a/cpp/src/arrow/compute/kernels/hash_aggregate_internal.h
+++ b/cpp/src/arrow/compute/kernels/hash_aggregate_internal.h
@@ -31,7 +31,7 @@
 #include "arrow/type_traits.h"
 #include "arrow/util/bit_util.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 /// C++ abstract base class for the HashAggregateKernel interface.
 /// Implementations should be default constructible and perform initialization in
@@ -205,4 +205,4 @@ void VisitGroupedValuesNonNull(const ExecSpan& batch, ConsumeValue&& valid_func)
                            [](uint32_t) {});
 }
 
-}  // namespace arrow::compute::internal
+}  // namespace arrow::compute::internal::vendored
diff --git a/cpp/src/arrow/compute/kernels/hash_aggregate_pivot.cc b/cpp/src/arrow/compute/kernels/hash_aggregate_pivot.cc
index c3dc070e4f..3c271ea64e 100644
--- a/cpp/src/arrow/compute/kernels/hash_aggregate_pivot.cc
+++ b/cpp/src/arrow/compute/kernels/hash_aggregate_pivot.cc
@@ -33,7 +33,7 @@
 #include "arrow/util/span.h"
 #include "arrow/visit_type_inline.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 using ::arrow::util::span;
 
@@ -456,7 +456,7 @@ void RegisterHashAggregatePivot(FunctionRegistry* registry) {
 
   {
     auto func = std::make_shared<HashAggregateFunction>(
-        "hash_pivot_wider", Arity::Ternary(), hash_pivot_doc, &default_pivot_options);
+        "vendored_hash_pivot_wider", Arity::Ternary(), hash_pivot_doc, &default_pivot_options);
     for (auto key_type : BaseBinaryTypes()) {
       // Anything that scatter() (i.e. take()) accepts can be passed as values
       auto sig = KernelSignature::Make(
@@ -469,4 +469,4 @@ void RegisterHashAggregatePivot(FunctionRegistry* registry) {
   }
 }
 
-}  // namespace arrow::compute::internal
+}  // namespace arrow::compute::internal::vendored
diff --git a/cpp/src/arrow/compute/kernels/pivot_internal.cc b/cpp/src/arrow/compute/kernels/pivot_internal.cc
index 7a65ddc212..6d120ee206 100644
--- a/cpp/src/arrow/compute/kernels/pivot_internal.cc
+++ b/cpp/src/arrow/compute/kernels/pivot_internal.cc
@@ -26,7 +26,7 @@
 #include "arrow/util/checked_cast.h"
 #include "arrow/visit_type_inline.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 using ::arrow::util::span;
 
diff --git a/cpp/src/arrow/compute/kernels/pivot_internal.h b/cpp/src/arrow/compute/kernels/pivot_internal.h
index faa808b7a2..d40c8d0bb4 100644
--- a/cpp/src/arrow/compute/kernels/pivot_internal.h
+++ b/cpp/src/arrow/compute/kernels/pivot_internal.h
@@ -28,7 +28,7 @@
 #include "arrow/type_fwd.h"
 #include "arrow/util/span.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 using PivotWiderKeyIndex = uint8_t;
 
diff --git a/cpp/src/arrow/compute/kernels/util_internal.cc b/cpp/src/arrow/compute/kernels/util_internal.cc
index 50d31362f1..bd28f46f15 100644
--- a/cpp/src/arrow/compute/kernels/util_internal.cc
+++ b/cpp/src/arrow/compute/kernels/util_internal.cc
@@ -30,6 +30,7 @@ using internal::checked_cast;
 
 namespace compute {
 namespace internal {
+namespace vendored {
 
 namespace {
 
@@ -63,6 +64,7 @@ void AddNullExec(ScalarFunction* func) {
   DCHECK_OK(func->AddKernel(std::move(input_types), OutputType(null()), NullToNullExec));
 }
 
+}  // namespace vendored
 }  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/util_internal.h b/cpp/src/arrow/compute/kernels/util_internal.h
index 1fe139c117..fea125a26a 100644
--- a/cpp/src/arrow/compute/kernels/util_internal.h
+++ b/cpp/src/arrow/compute/kernels/util_internal.h
@@ -39,6 +39,7 @@ namespace compute {
 class ScalarFunction;
 
 namespace internal {
+namespace vendored {
 
 template <typename T>
 using maybe_make_unsigned =
@@ -155,6 +156,7 @@ ArrayKernelExec GenerateArithmeticFloatingPoint(detail::GetTypeId get_id) {
 // A scalar kernel that ignores (assumed all-null) inputs and returns null.
 void AddNullExec(ScalarFunction* func);
 
+}  // namespace vendored
 }  // namespace internal
 }  // namespace compute
 }  // namespace arrow
diff --git a/cpp/src/arrow/compute/kernels/vector_rank.cc b/cpp/src/arrow/compute/kernels/vector_rank.cc
index d1323c2030..fd78ca7ca1 100644
--- a/cpp/src/arrow/compute/kernels/vector_rank.cc
+++ b/cpp/src/arrow/compute/kernels/vector_rank.cc
@@ -23,7 +23,7 @@
 #include "arrow/compute/registry.h"
 #include "arrow/util/math_internal.h"
 
-namespace arrow::compute::internal {
+namespace arrow::compute::internal::vendored {
 
 using ::arrow::util::span;
 
@@ -71,7 +71,7 @@ Result<NullPartitionResult> DoSortAndMarkDuplicate(
   using GetView = GetViewType<ArrowType>;
   using ArrayType = typename TypeTraits<ArrowType>::ArrayType;
 
-  ARROW_ASSIGN_OR_RAISE(auto array_sorter, GetArraySorter(*physical_type));
+  ARROW_ASSIGN_OR_RAISE(auto array_sorter, arrow::compute::internal::GetArraySorter(*physical_type));
 
   ArrayType array(input.data());
   ARROW_ASSIGN_OR_RAISE(auto sorted,
@@ -200,7 +200,7 @@ struct QuantileRanker : public BaseQuantileRanker<QuantileRanker> {
 // A derived class that emits rankings for the "rank_normal" function
 struct NormalRanker : public BaseQuantileRanker<NormalRanker> {
   static double TransformValue(double quantile) {
-    return ::arrow::internal::NormalPPF(quantile);
+    return ::arrow::internal::vendored::NormalPPF(quantile);
   }
 };
 
@@ -380,7 +380,7 @@ class RankMetaFunction : public RankMetaFunctionBase<RankMetaFunction> {
   }
 
   RankMetaFunction()
-      : RankMetaFunctionBase("rank", Arity::Unary(), rank_doc, &kDefaultOptions) {}
+      : RankMetaFunctionBase("vendored_rank", Arity::Unary(), rank_doc, &kDefaultOptions) {}
 
   static inline const auto kDefaultOptions = RankOptions::Defaults();
 };
@@ -396,7 +396,7 @@ class RankQuantileMetaFunction : public RankMetaFunctionBase<RankQuantileMetaFun
   static RankerType GetRanker(const RankQuantileOptions& options) { return RankerType(); }
 
   RankQuantileMetaFunction()
-      : RankMetaFunctionBase("rank_quantile", Arity::Unary(), rank_quantile_doc,
+      : RankMetaFunctionBase("vendored_rank_quantile", Arity::Unary(), rank_quantile_doc,
                              &kDefaultOptions) {}
 
   static inline const auto kDefaultOptions = RankQuantileOptions::Defaults();
@@ -413,7 +413,7 @@ class RankNormalMetaFunction : public RankMetaFunctionBase<RankNormalMetaFunctio
   static RankerType GetRanker(const RankQuantileOptions& options) { return RankerType(); }
 
   RankNormalMetaFunction()
-      : RankMetaFunctionBase("rank_normal", Arity::Unary(), rank_normal_doc,
+      : RankMetaFunctionBase("vendored_rank_normal", Arity::Unary(), rank_normal_doc,
                              &kDefaultOptions) {}
 
   static inline const auto kDefaultOptions = RankQuantileOptions::Defaults();
@@ -427,4 +427,4 @@ void RegisterVectorRank(FunctionRegistry* registry) {
   DCHECK_OK(registry->AddFunction(std::make_shared<RankNormalMetaFunction>()));
 }
 
-}  // namespace arrow::compute::internal
+}  // namespace arrow::compute::internal::vendored
diff --git a/cpp/src/arrow/compute/kernels/vector_sort_internal.h b/cpp/src/arrow/compute/kernels/vector_sort_internal.h
index 6288aa26ea..4bc29e8646 100644
--- a/cpp/src/arrow/compute/kernels/vector_sort_internal.h
+++ b/cpp/src/arrow/compute/kernels/vector_sort_internal.h
@@ -31,6 +31,8 @@
 
 namespace arrow::compute::internal {
 
+namespace vendored {
+
 // Visit all physical types for which sorting is implemented.
 #define VISIT_SORTABLE_PHYSICAL_TYPES(VISIT) \
   VISIT(BooleanType)                         \
@@ -456,26 +458,6 @@ using MergeImpl = GenericMergeImpl<uint64_t, NullPartitionResult>;
 using ChunkedMergeImpl =
     GenericMergeImpl<CompressedChunkLocation, ChunkedNullPartitionResult>;
 
-// TODO make this usable if indices are non trivial on input
-// (see ConcreteRecordBatchColumnSorter)
-// `offset` is used when this is called on a chunk of a chunked array
-using ArraySortFunc = std::function<Result<NullPartitionResult>(
-    uint64_t* indices_begin, uint64_t* indices_end, const Array& values, int64_t offset,
-    const ArraySortOptions& options, ExecContext* ctx)>;
-
-Result<ArraySortFunc> GetArraySorter(const DataType& type);
-
-Result<NullPartitionResult> SortChunkedArray(ExecContext* ctx, uint64_t* indices_begin,
-                                             uint64_t* indices_end,
-                                             const ChunkedArray& chunked_array,
-                                             SortOrder sort_order,
-                                             NullPlacement null_placement);
-
-Result<NullPartitionResult> SortChunkedArray(
-    ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,
-    const std::shared_ptr<DataType>& physical_type, const ArrayVector& physical_chunks,
-    SortOrder sort_order, NullPlacement null_placement);
-
 Result<NullPartitionResult> SortStructArray(ExecContext* ctx, uint64_t* indices_begin,
                                             uint64_t* indices_end,
                                             const StructArray& array,
@@ -788,7 +770,7 @@ struct ResolvedTableSortKey {
                                   null_count);
     };
 
-    return ::arrow::compute::internal::ResolveSortKeys<ResolvedTableSortKey>(
+    return ::arrow::compute::internal::vendored::ResolveSortKeys<ResolvedTableSortKey>(
         *table.schema(), sort_keys, factory);
   }
 
@@ -813,4 +795,22 @@ inline Result<std::shared_ptr<ArrayData>> MakeMutableFloat64Array(
   return ArrayData::Make(float64(), length, {nullptr, std::move(data)}, /*null_count=*/0);
 }
 
+}  // namespace vendored
+// TODO make this usable if indices are non trivial on input
+// (see ConcreteRecordBatchColumnSorter)
+// `offset` is used when this is called on a chunk of a chunked array
+using ArraySortFunc = std::function<Result<vendored::NullPartitionResult>(
+  uint64_t* indices_begin, uint64_t* indices_end, const Array& values, int64_t offset,
+  const vendored::ArraySortOptions& options, ExecContext* ctx)>;
+Result<ArraySortFunc> GetArraySorter(const DataType& type);
+Result<vendored::NullPartitionResult> SortChunkedArray(ExecContext* ctx, uint64_t* indices_begin,
+  uint64_t* indices_end,
+  const ChunkedArray& chunked_array,
+  SortOrder sort_order,
+  NullPlacement null_placement);
+
+Result<vendored::NullPartitionResult> SortChunkedArray(
+ExecContext* ctx, uint64_t* indices_begin, uint64_t* indices_end,
+const std::shared_ptr<DataType>& physical_type, const ArrayVector& physical_chunks,
+SortOrder sort_order, NullPlacement null_placement);
 }  // namespace arrow::compute::internal
diff --git a/cpp/src/arrow/util/math_internal.cc b/cpp/src/arrow/util/math_internal.cc
index 604af45a49..32fd7e7963 100644
--- a/cpp/src/arrow/util/math_internal.cc
+++ b/cpp/src/arrow/util/math_internal.cc
@@ -21,7 +21,7 @@
 
 #include "arrow/util/logging.h"
 
-namespace arrow::internal {
+namespace arrow::internal::vendored {
 
 double NormalPPF(double p) {
   DCHECK(p >= 0.0 && p <= 1.0);
@@ -127,4 +127,4 @@ double NormalPPF(double p) {
   }
 }
 
-}  // namespace arrow::internal
+}  // namespace arrow::internal::vendored
diff --git a/cpp/src/arrow/util/math_internal.h b/cpp/src/arrow/util/math_internal.h
index 3ff30cabf2..d5374a35d0 100644
--- a/cpp/src/arrow/util/math_internal.h
+++ b/cpp/src/arrow/util/math_internal.h
@@ -24,7 +24,7 @@
 #include "arrow/util/macros.h"
 #include "arrow/util/visibility.h"
 
-namespace arrow::internal {
+namespace arrow::internal::vendored {
 
 /// \brief Percent-point / quantile function (PPF) of the normal distribution.
 ///
@@ -59,4 +59,4 @@ double NeumaierSum(Range&& inputs) {
   return sum + c;
 }
 
-}  // namespace arrow::internal
+}  // namespace arrow::internal::vendored
diff --git a/cpp/src/arrow/util/reflection_internal.h b/cpp/src/arrow/util/reflection_internal.h
index 5d281a265f..62cb2cda7b 100644
--- a/cpp/src/arrow/util/reflection_internal.h
+++ b/cpp/src/arrow/util/reflection_internal.h
@@ -26,6 +26,7 @@
 
 namespace arrow {
 namespace internal {
+namespace vendored {
 
 template <typename...>
 struct all_same : std::true_type {};
@@ -131,5 +132,6 @@ struct has_enum_traits : std::false_type {};
 template <typename T>
 struct has_enum_traits<T, void_t<typename EnumTraits<T>::Type>> : std::true_type {};
 
+}  // namespace vendored
 }  // namespace internal
 }  // namespace arrow
